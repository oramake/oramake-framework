#!/bin/bash

# script: oms
# Выполняет команду по управлению прикладным модулем.
#
# Использование:
#   oms <subcommand> [common-options] [options] [args]
#
# Выполнение "oms --version" выводит информацию о версии скрипта.
# Выполнение "oms --help" выводит справочную информацию со списком
# команд.
#
# Возможные команды ( subcommand):
#    gen-schema-run             - генерация файла по установке последней версии
#                                 объектов модудя в БД ( run.sql)
#    gen-schema-revert          - генерация файла по удалению объектов модуля
#                                 из БД
#    set-version                - установка версии модуля
#    show-svn-info              - вывод информации о файла модуля из Subversion
#
#
# Общие опции ( common-options):
#       --debug-level DBG_LEVEL - установить уровень вывода отладочной
#                                 информации ( 0 не выводить, 1 базовый,
#                                 2 расширенный, 3 расширенный с выводом
#                                 содержимого временных файлов, по умолчанию
#                                 из переменной окружения <OMS_DEBUG_LEVEL>,
#                                 при отсутствии 0)
#   -d, --directory DIR         - путь к корневому каталогу модуля ( по
#                                 умолчанию текущий каталог)
#   -n, --dry-run               - не выполнять команды, а только выводить их
#   -h, --help                  - вывести справку по использованию
#
# Допустимые значения опций ( options) и аргументов ( args) зависят от
# выполняемой команды ( subcommand).
#
# Справку по опциям и аргументам команды можно получить с помощью вызова:
#   oms <subcommand> --help
#



# group: Переменные



# group: Информация о версии

# var: OMS_VERSION
# Версия программы
OMS_VERSION=2.0.0

# var: fileRevisionValue
# Строка с номером последней правки, в которой был изменен файл
fileRevisionValue='$Revision:: 24969048 $'

# var: fileChangeDateValue
# Строка с последней датой изменения файла
fileChangeDateValue='$Date:: 2017-06-22 17:48:12 +0300 #$'



# Подключение общих констант и функций
source oms-common.sh || exit 11



# group: Настроечные параметры

# var: subcommandList
# Список команд, обрабатываемых скриптом
declare -a subcommandList=( \
  "gen-schema-revert" \
  "gen-schema-run" \
  "set-version" \
  "show-svn-info" \
)



# group: Параметры вызова

# var: rootDir
# Корневой каталог модуля.
rootDir=""

# var: subcommand
# Команда, которую нужно выполнить для модуля.
subcommand=""

# var: moduleVersion
# Версия модуля ( используется в команде set-version)
moduleVersion=""

# var: isQuiet
# Флаг минимизации выводимой информации.
isQuiet=""

# var: isUsedOnly
# Флаг установки указанного номера версии только в случае его использования
# в файлах модуля ( команда <set-version>).
isUsedOnly=""



# group: Параметры выполнения

# var: isUseSubversion
# Флаг возможности использования Subversion
isUseSubversion=0



# group: Возврат значений из функций

# var: processCommonOptionCount
# Устанавливается в функции <processCommonOption>.
#
processCommonOptionCount=0



# group: Функции



# group: Общие



# func: usage
# Выводит информацию об использовании.
#
usage()
{
  cat <<END
Execute command for module.

Usage:
  oms <subcommand> [common-options] [options] [args]

Type 'oms --version' to see script version.
Type 'oms --help' to see this help.

Common options:
      --debug-level DBG_LEVEL set level for print debug information ( 0 - 3)
  -d, --directory DIR         path to module root directory ( default: current)
  -n, --dry-run               don't actually run any commands; just print them
  -h, --help                  show help for subcommand

Available subcommands:
END

  local cmd
  for cmd in "${subcommandList[@]}"; do
    echo "  $cmd"
  done

  cat <<END

For help on specific subcommand type:
  oms <subcommand> --help
END
}



# func: processCommonOption
# Разбор общих опций командной строки.
#
# Параметры:
# ...                         - аргументы командной строки
#
# Возврат:
# processCommonOptionCount    - число обработанных аргументов
#
processCommonOption()
{
  logDebug2 "start[$#]:" "$@"
  processCommonOptionCount=0
  while [ $# != 0 ]; do
    case $1 in
      --debug-level)
        setDebugLevel "$2"
        (( ++processCommonOptionCount ))
        shift
        ;;
      -d | --directory)
        rootDir="$2"
        logDebug3 "Set rootDir: '$rootDir'"
        (( ++processCommonOptionCount ))
        shift
        ;;
      -n | --dry-run)
        setDryRun
        ;;
      -h | --help)
        if [[ -z $subcommand ]]; then
          usage
        else
          usage_$subcommand
        fi
        exitScript
        ;;
      *)
        break
        ;;
    esac
    (( ++processCommonOptionCount ))
    shift
  done
  logDebug3 "finished: processCommonOptionCount=$processCommonOptionCount"
}



# func: parseOption
# Разбор аргументов командной строки.
#
# Параметры:
# ...                         - аргументы командной строки
#
parseOption()
{
  logDebug2 "start..."
  while [ $# != 0 ]; do
    if [[ -z $subcommand ]]; then
      processCommonOption "$@"
      if ! (( processCommonOptionCount )); then
        case $1 in
          --version)
            showVersion
            exitScript
            ;;
          -* | --*)
            exitArgError "Illegal common option: '$1'."
            ;;
          *)
            local cmd
            for cmd in "${subcommandList[@]}"; do
              if [[ $cmd == $1 ]]; then
                subcommand="$1"
                logDebug3 "Set subcommand: '$subcommand'"
                break
              fi
            done
            if [[ -z "$subcommand" ]] ; then
              exitArgError "Unknown subcommand: '$1'."
            fi
            ;;
        esac
      elif (( processCommonOptionCount > 1 )); then
        local i=$processCommonOptionCount
        while (( --i )); do shift; done
      fi
    else
      case $1 in
        -* | --*)
          exitArgError "Illegal subcommand option: '$1'."
          ;;
        *)
          exitArgError "Illegal subcommand argument: '$1'."
          ;;
      esac
    fi
    shift
    if [[ -n $subcommand ]]; then
      local parseFunction="parseOption_$subcommand"
      if type -t $parseFunction >/dev/null; then
        $parseFunction "$@"
        break
      fi
    fi
  done

  # Проверяем параметры выполнения
  if [[ -z "$subcommand" ]]; then
    exitArgError "Subcommand not expected."
  fi

  # Устанавливаем значения по умолчанию
  if [[ -z $rootDir ]]; then
    rootDir="."
    logDebug3 "Set rootDir: '$rootDir'"
  fi
}



# group: gen-schema-revert
# Генерирует файл DB/Install/Schema/Last/revert.sql
# ( см. <Структура каталогов>).
#
# Замечания:
# - команда должна выполняться из каталога модуля;
# - для генерации используется информация из имён файлов, поэтому для
#   получения корректного скрипта имена файлов должны соответствовать принятым
#   соглашениям;



# func: usage_gen-schema-revert
# Выводит информацию об использовании gen-schema-revert
# ( см. <exec_gen-schema-revert>).
usage_gen-schema-revert()
{
  cat <<END
Generate file DB/Install/Schema/revert.sql.

Usage:
  oms gen-schema-revert [common-options]

The current directory must be the module directory ( Trunk).


Type 'oms --help' to see help for common-options.
END
}



# func: parseOption_gen-schema-revert
# Разбор параметров команды <gen-schema-revert>.
#
parseOption_gen-schema-revert()
{
  processCommonOption "$@"
}



# func: gen-schema-revert_file
# Выводит текст генерируемого файла в stdout.
gen-schema-revert_file()
{
  cat <<END
-- script: Install/Schema/Last/revert.sql
-- Отменяет установку модуля, удаляя созданные объекты схемы.
END
  local headerFlag=0
  for packageFileName in \
    $(find "$rootDir/DB/"* -maxdepth 0 -name pkg*.pks -exec basename {} \; | sort); do
    if (( headerFlag == 0)); then
      cat <<END


-- Пакеты

END
      headerFlag=1
    fi;
    echo "drop package "${packageFileName%.*}
    echo "/"
  done;
  headerFlag=0
  for typeFileName in \
    $(find "$rootDir/DB/"* -maxdepth 0 -name *_t.typ -exec basename {} \; | sort); do
    if (( headerFlag == 0)); then
      cat <<END


-- Типы

END
      headerFlag=1
    fi;
    echo "@oms-drop-type "${typeFileName%.*}
  done;
  headerFlag=0
  for typeFileName in \
    $(find "$rootDir/DB/"* -maxdepth 0 -name *.jav -exec basename {} \; | sort); do
    if (( headerFlag == 0)); then
      cat <<END


-- Java sources

END
      headerFlag=1
    fi;
    echo "drop java source \""${typeFileName%.*}"\""
    echo "/"
  done;
  headerFlag=0
  for viewFileName in \
    $(find "$rootDir/DB/Install/Schema/Last/"* -maxdepth 0 -name *.vw -exec basename {} \; | sort); do
    if (( headerFlag == 0)); then
      cat <<END


-- Представления

END
      headerFlag=1
    fi;
    echo "drop view "${viewFileName%.*}
    echo "/"
  done
  headerFlag=0
  for tableFileName in \
    $(find "$rootDir/DB/Install/Schema/Last/"* -maxdepth 0 -name *.tab -exec basename {} \; | sort); do
    if (( headerFlag == 0)); then
      cat <<END


-- Внешние ключи

END
      headerFlag=1
    fi
    echo "@oms-drop-foreign-key "${tableFileName%.*}
  done
  headerFlag=0
  for mviewFileName in \
    $(find "$rootDir/DB/Install/Schema/Last/"* -maxdepth 0 -name *.snp -exec basename {} \; | sort); do
    if (( headerFlag == 0)); then
      cat <<END


-- Материализованные представления

END
      headerFlag=1
    fi
    echo "drop materialized view "${mviewFileName%.*}
    echo "/"
  done
  headerFlag=0
  for tableFileName in \
    $(find "$rootDir/DB/Install/Schema/Last/"* -maxdepth 0 -name *.tab -exec basename {} \; | sort); do
    if (( headerFlag == 0)); then
      cat <<END


-- Таблицы

END
      headerFlag=1
    fi
    echo "drop table "${tableFileName%.*}
    echo "/"
  done
  headerFlag=0
  for sequenceFileName in \
    $(find "$rootDir/DB/Install/Schema/Last/"* -maxdepth 0 -name *.sqs -exec basename {} \; | sort); do
    if (( headerFlag == 0)); then
      cat <<END


-- Последовательности

END
      headerFlag=1
    fi
    echo "drop sequence "${sequenceFileName%.*}
    echo "/"
  done
}



# func: exec_gen-schema-revert
# Генерирует файл DB/Install/Schema/revert.sql ( выволнение команды
# <gen-schema-revert>).
exec_gen-schema-revert()
{
  local revertFilePath="$rootDir/DB/Install/Schema/Last/revert.sql"
  local revertFilePathTemp=${revertFilePath}".$$"
  gen-schema-revert_file | unix2dos > $revertFilePathTemp
  cp $revertFilePathTemp $revertFilePath
  rm -f $revertFilePathTemp;
}



# group: gen-schema-run
# Генерирует файл DB/Install/Schema/Last/run.sql
# ( см. <Структура каталогов>).
#
# Замечания:
# - команда должна выполняться из каталога модуля;
# - для генерации используется информация из имён файлов, поэтому для
#   получения корректного скрипта имена файлов должны соответствовать принятым
#   соглашениям;



# func: usage_gen-schema-run
# Выводит информацию об использовании gen-schema-run
# ( см. <exec_gen-schema-run>).
usage_gen-schema-run()
{
  cat <<END
Generate file DB/Install/Schema/run.sql.

Usage:
  oms gen-schema-run [common-options]

The current directory must be the module directory ( Trunk).


Type 'oms --help' to see help for common-options.
END
}



# func: parseOption_gen-schema-run
# Разбор параметров команды <gen-schema-run>.
#
parseOption_gen-schema-run()
{
  processCommonOption "$@"
}



# func: gen-schema-run_file
# Выводит текст генерируемого файла в stdout.
gen-schema-run_file()
{
  cat <<END
-- script: Install/Schema/Last/run.sql
-- Выполняет установку последней версии объектов схемы.


-- Определяем табличное пространство для индексов
@oms-set-indexTablespace.sql
END
  local headerFlag=0
  for tableFileName in \
    $(find "$rootDir/DB/Install/Schema/Last/"* -maxdepth 0 -name *.tab -exec basename {} \; | sort); do
    if (( headerFlag == 0)); then
      cat <<END


-- Таблицы

END
      headerFlag=1
    fi;
    echo "@oms-run "${tableFileName}
  done;
  headerFlag=0
  for mviewFileName in \
    $(find "$rootDir/DB/Install/Schema/Last/"* -maxdepth 0 -name *.snp -exec basename {} \; | sort); do
    if (( headerFlag == 0)); then
      cat <<END


-- Материализованные представления

END
      headerFlag=1
    fi;
    echo "@oms-run "${mviewFileName}
  done;
  headerFlag=0
  for constraintFileName in \
    $(find "$rootDir/DB/Install/Schema/Last/"* -maxdepth 0 -name *.con -exec basename {} \; | sort); do
    if (( headerFlag == 0)); then
      cat <<END


-- Outline-ограничения целостности

END
      headerFlag=1
    fi;
    echo "@oms-run "${constraintFileName}
  done;
  headerFlag=0
  for sequenceFileName in \
    $(find "$rootDir/DB/Install/Schema/Last/"* -maxdepth 0 -name *.sqs -exec basename {} \; | sort); do
    if (( headerFlag == 0)); then
      cat <<END


-- Последовательности

END
      headerFlag=1
    fi;
    echo "@oms-run "${sequenceFileName}
  done;
}



# func: exec_gen-schema-run
# Генерирует файл DB/Install/Schema/run.sql ( выволнение команды
# <gen-schema-run>).
exec_gen-schema-run()
{
  local runFilePath="$rootDir/DB/Install/Schema/Last/run.sql"
  local runFilePathTemp=${runFilePath}".$$"
  gen-schema-run_file | unix2dos > $runFilePathTemp
  cp $runFilePathTemp $runFilePath
  rm -f $runFilePathTemp;
}



# group: show-svn-info
# Возвращает информацию о файлах модуля из Subversion
# ( см. <exec_show-svn-info>).



# func: usage_show-svn-info
# Выводит информацию об использовании команды <show-svn-info>.
#
usage_show-svn-info()
{
  cat <<END
Show information about module's files from Subversion.

Usage:
  oms show-svn-info [common-options] [options]

Type 'oms --help' to see help for common-options.

Options:
  --quiet             - minimize output
                        ( string with format: "<svnversion> <svn_path>")
  --used-only         - set version number only if it used in module
END
}



# func: parseOption_show-svn-info
# Разбор параметров команды <show-svn-info>.
#
parseOption_show-svn-info()
{
  logDebug2 "start[$#]:" "$@"
  while [ $# != 0 ]; do
    processCommonOption "$@"
    if ! (( processCommonOptionCount )); then
      case $1 in
        --quiet)
          isQuiet=1
          logDebug3 "Set isQuiet: $isQuiet"
          ;;
        -* | --*)
          exitArgError "Illegal subcommand option: '$1'."
          ;;
        *)
          exitArgError "Illegal subcommand argument: '$1'."
          ;;
      esac
    elif (( processCommonOptionCount > 1 )); then
      local i=$processCommonOptionCount
      while (( --i )); do shift; done
    fi
    shift
  done
}



# func: exec_show-svn-info
# Возвращает информацию о файлах модуля из Subversion ( выполнение команды
# <show-svn-info>).
#
# Параметры выполнения:
# isQuiet                     - сокращенный режим вывода
#
# В сокращенном режиме вывода выводится строка формате
# "<svnversion> <svn_path>", где:
# svnversion                  - информация о версии файлов, возвращаемая
#                               командой svnversion ( входит в состав
#                               Subversion, подробнее см. "svnversion --help")
# svn_path                    - путь в Subversion, из которого были получены
#                               файлы модуля ( начиная с имени репозитария)
#
#
exec_show-svn-info()
{
  logDebug2 "start: ..."
  local execResult=0
  local version=""

  # Определяем svnModuleRootFilePath
  getSvnModuleRoot "$rootDir"
  if [[ -n $svnModuleRootFilePath ]]; then
    version="$(svnversion --quiet --no-newline "$rootDir")"
    if (( $? )) || [[ -z $version ]]; then
      exitError \
          "error on get svnversion for path: '$rootDir'"
    fi
  fi

  logDebug "SVN path: '$svnModuleRootFilePath'"
  logDebug "SVN version info: '$version'"
  if (( isQuiet )); then
    if [[ -n "$version" ]]; then
      echo "$version $svnModuleRootFilePath"
    fi
  else
    echo "SVN path         : $svnModuleRootFilePath"
    echo "SVN version info : $version"
  fi

  logDebug3 "finished: return $execResult"
  return $execResult
}



# group: set-version
# Установка текущей версии модуля ( см. <exec_set-version>).



# func: usage_set-version
# Выводит информацию об использовании команды <set-version>.
#
usage_set-version()
{
  cat <<END
Set module version.

Usage:
  oms set-version [common-options] [options] VERSION

Type 'oms --help' to see help for common-options.

Arguments:
  VERSION             - new version number ( digits delimited by dot, for
                        example "1.5.0")
Options:
  --quiet             - minimize output ( print only new version number)
  --used-only         - set version number only if it used in module
END
}



# func: parseOption_set-version
# Разбор параметров команды <set-version>.
#
parseOption_set-version()
{
  logDebug2 "start[$#]:" "$@"
  while [ $# != 0 ]; do
    processCommonOption "$@"
    if ! (( processCommonOptionCount )); then
      case $1 in
        --quiet)
          isQuiet=1
          logDebug3 "Set isQuiet: $isQuiet"
          ;;
        --used-only)
          isUsedOnly=1
          logDebug3 "Set isUsedOnly: $isUsedOnly"
          ;;
        -* | --*)
          exitArgError "Illegal subcommand option: '$1'."
          ;;
        *)
          if [[ -n $moduleVersion ]]; then
            exitArgError "Illegal subcommand argument: '$1'."
          fi
          if [[ -z ${1//[0-9]*/} ]] && [[ -z ${1//*[0-9]/} ]]; then
            local s=${1//[0-9]/}
            if [[ -z ${s//./} ]]; then
              moduleVersion="$1"
              logDebug3 "Set moduleVersion: '$moduleVersion'"
            fi
          fi
          if [[ -z $moduleVersion ]]; then
            exitArgError "Bad version value: '$1'"
          fi
          ;;
      esac
    elif (( processCommonOptionCount > 1 )); then
      local i=$processCommonOptionCount
      while (( --i )); do shift; done
    fi
    shift
  done

  # Проверяем параметры
  if [[ -z "$moduleVersion" ]]; then
    exitArgError "Version not expected."
  fi
}



# func: exec_set-version
# Устанавливает текущую версию модуля ( выполнение команды <set-version>).
# При выполнении команды обновляется значение в тэге "<version>" map-файла
# ( Doc/map.xml) и в тэге SubTitle меню автодокументации
# ( DB/OmsModule/NaturalDocs/Menu.txt).
#
# Параметры выполнения:
# isUsedOnly                  - флаг установки номера версии только в том
#                               случае, если он используется в модуле
# isQuiet                     - сокращенный режим вывода ( выводится только
#                               номер версии, если она была установлена)
#
#
# Замечания:
# - использование версии в модуле подтверждается наличием подкаталогов в
#   с номером версии в ветке DB/Install либо документированием версии в
#   файле DB/Doc/version.txt ( по наличию строки, соответствующей шаблону
#   "group:[[:space:]]*$moduleVersion[[:space:]]")
# - в случае, если установка версии не выполнялась по условию, функция
#   возвращает <oms-common.sh::E_FALSE_RESULT>;
# - новая версия будет показана в меню документации после обновления докуменации
#   c помощью команды 'make gendoc';
#
exec_set-version()
{
  logDebug2 "start: ..."
  local execResult=1
  local isUsed=""
  if (( isUsedOnly )); then
    isUsed=0
    local checkDir=""
    local versionDir=""
    for checkDir in Config Data Grant Schema; do
      versionDir="$rootDir/DB/Install/$checkDir/$moduleVersion";
      if [[ -d $versionDir ]]; then
        isUsed=1
        logDebug2 "version used: directory found: '$versionDir'"
        break;
      else
        logDebug3 "check used: directory not found: '$versionDir'"
      fi
    done
    local checkFile="$rootDir/DB/Doc/version.txt"
    if (( ! isUsed )) && [[ -r $checkFile ]]; then
      if grep --ignore-case --quiet \
            "group:[[:space:]]*${moduleVersion//./\\.}[[:space:]]" \
            "$checkFile"; \
          then
        isUsed=1
        logDebug2 "version used: found in '$checkFile'"
      else
        logDebug3 "check used: version not found in '$checkFile'"
      fi
    fi
  fi
  if (( isUsedOnly && ! isUsed )); then
    logDebug "skip set version ( not used): '$moduleVersion'"
    if (( ! isQuiet )); then
      printMessage "Skip set version ( not used): $moduleVersion"
    fi
  else
    local dstFile="$rootDir/Doc/map.xml"
    $runCmd sed --in-place \
      -e "s|<version>.*</version>|<version>$moduleVersion</version>|" \
      -e 's/$/\x0D/' \
      "$dstFile" \
      || exitError "error on set version in map file: '$dstFile'"
    dstFile="$rootDir/DB/OmsModule/NaturalDocs/Menu.txt"
    $runCmd sed --in-place \
      -e "s|^SubTitle:.*|SubTitle: Версия $moduleVersion|" \
      "$dstFile" \
      || exitError \
        "error on set version in SubTitle of documentation menu: '$dstFile'"
    execResult=0
    logDebug "set module version: '$moduleVersion'"
    if (( isQuiet )); then
      echo "$moduleVersion"
    else
      printMessage "module version changed: $moduleVersion ( please, run \"make gendoc\")"
    fi
  fi
  logDebug3 "finished: return $execResult"
  return $execResult
}



# Разбор параметров
parseOption "$@"

# Выполняем команду
exec_$subcommand

# Завершаем выполнение
exitScript "$?"
