Title: Описание

Group: Назначение

Проект OraMakeSystem ( OMS) предназначен для стандартизации структуры и
автоматизации операций при разработке программных модулей для БД Oracle.

Возможности:
- создание и обновление стандартной структуры модуля
- автоматизация операций
- автодокументирование исходного кода
- загрузка файлов ( программных единиц и данных) в БД
- установка модуля в БД



Group: Создание структуры модуля

Для использования OMS в программном модуле, в него должны быть добавлен
минимальный набор стандартных файлов и каталогов ( см. <Структура каталогов>).
Эта операция выполняется командой "create-module" скрипта <oms>. Оптимальным
вариантом является предварительное добавление модуля ( каталога
<ModuleName>/Trunk) в систему контроля версий Subversion, т.к. в этом случае
скрипт сможет выполнить необходимую настройку параметров создаваемых файлов и
каталогов в Subversion.

Пример ( создание структуры для модуля DocumentLink):

(code)

$ cd /tmp

$ svn co -q svn://.../DocumentLink/Trunk DocumentLink

$ cd DocumentLink

$ oms create-module -d . DocumentLink

$ svn status
A      DB\loaddeps.mk
A      DB\OmsModule
A      DB\OmsModule\Load
A      DB\OmsModule\NaturalDocs
A      DB\OmsModule\NaturalDocs\Topics.txt
A      DB\OmsModule\NaturalDocs\Menu.txt
A      DB\OmsModule\NaturalDocs\Languages.txt
A      DB\OmsModule\NaturalDocs\Data
A      DB\OmsModule\init.mk
A      DB\OmsModule\common.mk
A      DB\Doc
A      DB\Doc\todo.txt
A      DB\Doc\install.txt
A      DB\Doc\readme.txt
A      DB\Doc\bugs.txt
A      DB\pkg_DocumentLink.pkb
A      DB\pkg_DocumentLink.pks
A      DB\Makefile
A      Doc\DB
A      Doc\DB\AutoGen
A      Doc\map.xml
A      Makefile

(end)

( последняя команда в примере показывает созданные файлы и каталоги)

После создания структуры можно вручную внести дополнительные изменения (
например, в файл Doc/map.xml), после чего сохранить изменения в Subversion
командой "svn commit".



Group: Обновление структуры модуля

Для использовния в програмных модулях новых возможностей, появившихся в новых
версиях OMS, требуется обновить стандартные файлы OMS, включенные в состав
модуля ( например, DB/Makefile и т.д.). Сначала новую версия OMS нужно
устанавить на локальный компьютер ( см. <Установка>), после чего при
очередной доработке програмного модуля желательно обновить его структуру.
Процесс обновления автоматизирован и выполняется скриптом <oms-update-module>,
который вызывается при выполнении в програмном модуле через make цели
<update-oms-version> ( текущую версию OMS-файлов модуля можно посмотреть с
помощью команды "make show-oms-version").

Пример:

(code)

$ make show-oms-version
make[1]: Entering directory `/cygdrive/d/users/mao/oracle/scripts/dic/DB'
OMS files version: 1.4.1 ( rev. 468, 2009-05-13)
make[1]: Leaving directory `/cygdrive/d/users/mao/oracle/scripts/dic/DB'

$ make update-oms-version
make[1]: Entering directory `/cygdrive/d/users/mao/oracle/scripts/dic/DB'
oms-update-module: updated OMS revision: 468 -> 566
make[1]: Leaving directory `/cygdrive/d/users/mao/oracle/scripts/dic/DB'

$ make show-oms-version
make[1]: Entering directory `/cygdrive/d/users/mao/oracle/scripts/dic/DB'
OMS files version: 1.4.1 ( rev. 566, 2009-12-08)
make[1]: Leaving directory `/cygdrive/d/users/mao/oracle/scripts/dic/DB'

$ svn status
M      DB\OmsModule\NaturalDocs\Languages.txt
M      DB\OmsModule\init.mk
M      DB\OmsModule\common.mk
M      DB\Makefile

(end)

В этом примере OMS-файлы модуля были обновлены с правки 468 до правки
566 ( номера правок относятся к изменениям, внесенным в рамках OMS), при
этом обе версии основаны на релизе OMS 1.4.1. Рекомендуется фиксировать
изменения структуры модуля в виде отдельной правки в Subversion ( т.е. не
объединять их с другими изменениями в модуле).

Иногда при обновлении возникают ошибки, связанные с невозможностью
автоматического слияния изменений, внесенных в рамках OMS, с локальными
изменениями, внесенными в файлы в рамках модуля ( обычно это касается файла
DB/Makefile).

Пример ( ошибка обновления):

(code)

make[1]: Entering directory `/cygdrive/d/users/mao/oracle/scripts/dic/DB'
1 out of 4 hunks FAILED -- saving rejects to file ../DB/Makefile.562.rej
oms-update-module: error patch: ../DB/Makefile, p----562.diff
oms-update-module: updated OMS revision: 468 -> 566
make[1]: Leaving directory `/cygdrive/d/users/mao/oracle/scripts/dic/DB'

(end)

В данном случае не удалось внести некоторые изменения в файл DB/Makefile
( изменения, которые не удалось внести, были сохранены в файле
DB/Makefile.562.rej), остальные файлы были успешно обновлены. Для решения
проблемы нужно вручную внести необходимые изменения, выполненные в рамках OMS.
Возможен также альтернативный способ: получить стандартный файл DB/Makefile
( удалив существующий и выполнив команду "create-module" скрипта <oms>) и
вручную внести в него локальные изменения, внесенные ранее в рамках модуля.



group: Параметры модуля

Параметры текущего модуля получаются из файла Doc/map.xml.

Используются значения из следующих
тэгов:

initialPath         - первоначальный путь к корневому каталогу модуля в
                      Subversion, включая имя репозитария и правку,
                      в которой был создан каталог

Считается уникальным идентификатором модуля, никогда не должен изменяться
после первоначального заполнения ( в т.ч. в случае переноса модуля в другой
репозитарий).
Пример: "<initialPath>Oracle/Module/ModuleInfo@711</initialPath>".

path                - путь к корневому каталогу модуля в Subversion
                      ( начиная с имени репозитария)

Считается текущим уникальным идентификатором модуля, значение должно
корректироваться в случае переименования или перемещения модуля.
Пример: "<path>Oracle/Module/ModuleInfo</path>".

version             - текущая версия модуля ( последовательность из нескольких
                      ( обычно трех) неотрицательных целых чисел, разделяемых
                      точками, например 2.1.0)

Номер версии должен увеличиваться в при внесении изменений в модуль.
Пример: "<version>1.0.0</version>".
Для установки версии можно использовать команду

(code)

$ make set-version MODULE_VERSION=???

(end)

либо

(code)

$ oms set-version ???

(end)

( команды выполняются в каталоге модуля, вместо ??? нужно указать
корректный номер версии, например 1.2.0)

Также для удобства использования реализовано автоматическое изменение номера
версии в случае выполнения команды "make install INSTALL_VERSION=??? ..." и
наличия подтверждения корректности указанного номер версии ( например, наличие
каталога DB/Install/Config/???), после чего необходимо обновить документацию
командой "make gendoc":

(code)

$ make install INSTALL_VERSION=2.7.0 ...
OMS: module version changed using INSTALL_VERSION: 2.7.0 ( please, run "make gendoc")
...

(end)

Значения указанных выше тэгов ( initialPath, path, version) должны обязательно
присутствовать файле Doc/map.xml, т.к. они используются при автоматическом
сохранении в БД информации об выполнении установки модуля ( см.
<Установка модуля в БД>, подцель install-save-info).



Group: Автоматизация операций

Автоматизация обеспечивает простое выполнение сложных операций.

Для автоматизации операций используется утилита GNU Make
( http://www.gnu.org/software/make), которая входит в состав Gygwin.

Настройки Make находятся в файлах
- Makefile
- DB/Makefile
- DB/OmsModule/common.mk


Настроенные операции ( цели в терминах Make) документируются на основе файла
DB/Makefile и отражаются в разделе "О модуле\Сборка".

Для выполнения операции нужно в корневом каталоге проекта выполнить

(start code)

$ make <имя цели>

(end)

Запуск make желательно производить из bash ( Cygwin Terminal), однако в
большинстве случаев все будет корректно работать и при запуске из коммандной
строки Windows.

Для обеспечения выполнения Make в каталоге, отличном от текущего, можно
использовать параметр -C:

(start code)

$ make -C "<путь к каталогу>" <имя цели>

(end)

Если имя цели не указано, то выполняется первая цель, присутствующая в
настроечном файле ( обычно это цель "all", выполняющая все операции по сборке
модуля).

При запуске Make можно указывать значения для переменных, которые используются
при выполнении операции ( обычно это пути к каталогам, специальные опции и
т.д.).

Например, вызов

(start code)

$ make gendoc GENDOC_DB_DIR="c:\tmp\doc"

(end)

вызовет генерацию документации в каталоге c:\tmp\doc ( если переменная
GENDOC_DB_DIR используется внутри make-файла в качестве пути для генерации
документации).

Часто используемые параметры make:
-B, --always-make           - безусловное достижение целей
-i, --ignore-errors         - игнорировать ошибки при выполнении команд
-k, --keep-going            - продолжать выполнение, даже если некоторые цели
                              не достигнуты ( из-за ошибки)


Group: Автодокументирование

Документирование производится автоматически с
на основе комментариев, присутствующих в файлах.
Для того, чтобы файл был документирован, он должен иметь определенное
расширение и в нем должны присутствовать комментарии определенного вида
( соглашение <Комментарии>). Для документирования используется утилита NaturalDocs
( http://www.naturaldocs.org), позволяющая формировать документацию в формате
HTML.

Примеры документируемых файлов:
Makefile, makefile            - make-файлы
*.java                        - Java
*.pks, *.pkb                  - PL/SQL пакеты
*.txt                         - текстовые файлы

Текстовые файлы отличаются от других тем, что для них не определен символ
начала комментария ( все строки считаются комментариями).

Для генерации документации нужно вызвать make для цели gendoc ( или all или без
указания цели) в корневом каталоге модуля:

(start code)
$ make gendoc
(end)

В результате должна обновиться документация в каталоге Doc/DB/AutoGen.

В случае, если в модуле добавлялись или удалялись документированные
файлы, следует использовать цель gendoc-menu:

(start code)
$ make gendoc-menu
(end)

При этом кроме документации к файлам
регенерируется также и меню автодокуметации
( см. соглашение <Меню документации>). Реализованы именно две цели gendoc и gendoc-menu,
потому что обычно цель gendoc достигается быстрее, чем gendoc-menu.
При вызове gendoc-menu цель gendoc вызывать не нужно.

Состояние файлов кэшируется во временных файлах каталога
DB/OmsModule/NaturalDocs/Data и при повторном вызове будет обновлена
документация только по тем файлам, которые были изменены.

Для принудительной регенерации документации можно использовать
стандартный флаг Make -B ( --always-make):

(start code)
$ make -B gendoc-menu
(end)

Параметры документирования определяются стандартными настройками NaturalDocs и
локальными настройками модуля, которые находятся в DB/OmsModule/NaturalDocs.
Обычно в рамках модуля не приходится вручную менять локальные настройки.
Файл Menu.txt генерируется автоматически с помощью цели gendoc-menu.
Предусмотрена возможность изменения правил для генерации меню
в рамках модуля с помощью создания в модуле конфигурационного файла
menu-config.txt ( см. <oms-auto-doc>).


Group: Загрузка файлов в БД

Предусмотрена возможность загрузки ( установки) файлов с программными
единицами и выполнение скриптов ( например, заполняющих стандартные
справочники) в БД.

Загрузка производится при выполнении в Make цели load ( которая также
включена в цель по умолчанию all).

(start code)

$ make load

(end)

Загрузка производится под пользователями, указанными в параметрах
<LOAD_USERID>, <LOAD_USERID2>, ..., <LOAD_USERID9> ( т.е. максимально можно
настроить загрузку в девять различных схем), например:

(start code)

$ make load LOAD_USERID=testuser/passwd@testdb

(end)

В случае, если в пароле содержится символ "$", то строка подключения должна
заключаться в одинарные кавычки, а символ "$" дублироваться. Например, для
загрузке с паролем "$jbk" командная строка должна выглядеть так:

(start code)

$ make load LOAD_USERID='testuser/$$jbk@testdb'

(end)

Указывать пользователей можно также в комбинации с параметром <LOAD_DB>
( <LOAD_DB2>,..., <LOAD_DB9>), что может быть удобнее при использовании.
Пример:

(start code)

$ make load LOAD_USERID=testuser/passwd LOAD_DB=testdb

(end)

Значения указанных выше параметров могут быть заданы как в DB/Makefile, так и
при запуске Make ( как в примерах). Загрузка производится только в случае, если
хотя бы одни из этих параметров непустой и есть файлы для загрузки в под
этим пользователем.

Если при загрузке задан параметр <LOAD_OPERATORID>, то сразу после подключения
к БД в случае наличия в ней модуля AccessOperator ( пакет pkg_Operator) будет
автоматически произведена регистрация под указанным оператором:

(start code)

$ make load LOAD_USERID=testuser/passwd@testdb LOAD_OPERATORID=operator/passwd

(end)

Значение указанного параметра можно задать также в DB/Makefile, причем по
умолчанию в качестве значения используется значение переменной окружения
ORACLE_OPERATOR.

Если при загрузке задан параметр <COMMON_SCHEMA>, то регистрация оператора
будет производиться при помощи модуля AccessOperator,
загруженного в данную схему.
Пример:

(start code)

$ make load LOAD_USERID=testuser/passwd@testdb LOAD_OPERATORID=operator/passwd COMMON_SCHEMA=commonschema

(end)

В данном примере для регистрации оператора будет вызван пакет commonSchema.pkg_Operator. Предварительно пользователю testuser должны быть выданы привилегии на выполнение пакета commonSchema.pkg_Operator.

Если в прикладном модуле существует файл DB/OmsModule/operatorLoginScript.sh, то регистрация оператора выполняется из него.

Пример скрипта operatorLoginScript.sh:
(start code)
#!/bin/bash

operatorLoginScriptLocal="
declare
  userName varchar2(1024);
begin
  execute immediate '
begin
  :userName := pkg_Operator.Login(
    operatorLogin => :operatorName
    , password    => :operatorPassword
  );
end;
'
  using
    out userName
    , in '\$(operatorName)'
    , in '\$(operatorPassword)'
  ;
exception when others then
  if SQLERRM like
        '%PLS-00201: identifier ''PKG_OPERATOR'' must be declared%'
      or SQLERRM like
        '%PLS-00201: identifier ''PKG_OPERATOR.LOGIN'' must be declared%'
      or SQLERRM like
        '%PLS-00904: insufficient privilege to access object %.PKG_OPERATOR%'
      or SQLERRM like
        '%ORA-06508: PL/SQL: could not find program unit being called:%'
      then
    null;
  else
    raise_application_error(
      -20001
      , 'Error during automatic operator login ('
        || ' operatorName=\"\$(operatorName)\"'
        || ').'
      , true
    );
  end if;
end;
/
"
(end)

Список файлов для загрузки в БД задается в DB/Makefile в переменной loadTarget
с помощью перечисления файлов с дополнительным суффиксом, определяющим,
под каким пользователем он должен быть загружен:

(start code)

loadTarget =                            \
  pkg_TestModule.pks.$(lu)              \
  pkg_TestModule.pkb.$(lu)              \


(end)

В данном примере файлы pkg_TestModule.pks и pkg_TestModule.pkb ( спецификация
и тело пакета pkg_TestModule) должны быть загружены под первым пользователем.
Символ "\" служит для продолжения логической строки на следующей строчке
( экранирует символ перевода строки и должен находиться непосредственно
перед ним).

Используемые суффиксы:
.$(lu)      - для загрузки под первым пользователем
.$(lu2)     - для загрузки под вторым пользователем
...         - ...
.$(lu8)     - для загрузки под восьмым пользователем
.$(lu9)     - для загрузки под девятым пользователем ( обычно используется
              для загрузки локальных скриптов, см. ниже)

Файлы могут указываться с путями относительно каталога DB ( в качестве
разделителя в пути должен использоваться "/"):

(start code)

loadTarget =                            \
  Data/tsm_action.sql.$(lu)             \
  pkg_TestModule.pks.$(lu)              \
  pkg_TestModule.pkb.$(lu)              \

(end)

В данном примере стал загружаться файл DB/Data/tsm_action.sql под первым
пользователем ( для заполнение справочника tsm_action).

Для простоты написания можно использовать строковую функцию
$(addsuffix SUFFIX,NAMES...), а также функцию $(wildcard PATTERN...) для
получения файлов из каталога по шаблону:

(start code)

loadTarget =                            \
  $(addsuffix .$(lu),                   \
    $(wildcard *.pk[s,b])               \
  )                                     \
  $(addsuffix .$(lu2),                  \
  )                                     \
  $(addsuffix .$(lu3),                  \
  )                                     \

(end)

Этот вариант обеспечивает загрузку всех пакетов ( файлов *.pks и *.pkb) из
каталога DB под первым пользователем.

Иногда возникает необходимость в создании скриптов, которые загружались бы
только при загрузке файлов в определенную БД ( возможно также, только под
определенным пользователем определенной БД). Такие скрипты называются
локальными. Они должны быть расположены в соответствии с соглашением
<Структура каталогов> ( см. раздел "Расположение локальных скриптов").
Для настройки загрузки локальных скриптов можно использовать девятого
пользователя и параметр <LOCAL_DB_DIR> ( либо <LOCAL_USER_DIR>, если
нужно загружать скрипты для определенного пользователя):

(start code)

loadTarget =                            \
  $(addsuffix .$(lu),                   \
    $(wildcard *.pk[s,b])               \
  )                                     \
  $(addsuffix .$(lu2),                  \
  )                                     \
  $(addsuffix .$(lu3),                  \
  )                                     \
  $(addsuffix .$(lu9), \
    $(wildcard Local/$(LOCAL_DB_DIR)/*.pk[s,b]) \
  ) \

(end)

По умолчанию значения параметров <LOCAL_DB_DIR> и <LOCAL_USER_DIR> определяются
на основе значения параметра <LOAD_USERID9>, т.о. обычно их не нужно явно
указывать.  При этом при загрузке в тестовую БД загружаются локальные скрипты
для соответствующей промышленной БД ( которая определяется с помощью
make-функции <getProductionDbName>).

Для обеспечения правильного порядка загрузки файлов в БД нужно задать
зависимости между ними. Зависимости задаются в файле DB/loaddeps.mk. Пример:

(start code)

pkg_TestModule.pkb.$(lu): \
  pkg_TestModule.pks.$(lu)

(end)

Эта зависимость обеспечивает загрузку спецификации пакета pkg_TestModule до
его тела, а также повторную загрузку тела пакета при обновлении спецификации
( зависимость действует только при загрузке под первым пользователем).

Если тело пакета pkg_TestModule зависит также от другого пакета ( например,
pkg_TestModuleBase), то можно написать такую зависимость:

(start code)

pkg_TestModule.pkb.$(lu):  \
  pkg_TestModule.pks.$(lu) \
  pkg_TestModuleBase.pks.$(lu)

(end)

Можно было также просто добавить еще одну зависимость для тела пакета
pkg_TestModule аналогично первому примеру.

Факт успешной загрузки файла в БД фиксируется во временных файлах каталога
DB/OmsModule/Load и при последующих вызовах make load файл не загружается
( пока он сам либо файлы, от которых зависит его загрузка, не будут изменены).

Для безусловной загрузки всех файлов можно применить вызов Make со стандартным
флагом -B ( --always-make):

(start code)

$ make -B load LOAD_USERID=testuser/passwd@testdb

(end)

Для ограничения списка загружаемых файлов, перечисленных в loadTarget, можно
использовать параметр LOAD_FILE_MASK. Значение параметра представляет собой
список ( через пробел или запятую) масок путей к файлам ( относительно каталога
DB). Например, для безусловной загрузки только тела пакета pkg_TestModule
нужно выполнить:

(start code)

$ make -B load LOAD_USERID=testuser/passwd@testdb LOAD_FILE_MASK=pkg_TestModule.pkb

(end)

Для ограничения безусловной загрузки только телом пакета pkg_TestModule и
файлами из каталога Data ( находящегося в каталоге DB) нужно выполнить:

(start code)

$ make -B load LOAD_USERID=testuser/passwd@testdb LOAD_FILE_MASK=pkg_TestModule.pkb,Data/*

(end)



Group: Установка модуля в БД

Для упрощения процесса установки предполагается единообразный способ установки
модулей.

Установка ( обновление) модуля в БД выполняется с помощью вызова make с целью
install с указанием устанавливаемой версии модуля, а также параметров
подключения к БД и логина оператора, выполняющего установку. Например, для
первоначальной установки последней версии модуля в БД нужно выполнить:

(start code)

$ make install INSTALL_VERSION=Last LOAD_USERID=testuser/passwd@testdb LOAD_OPERATORID=operator/passwd

(end)

Аналогично, для обновления модуля до версии 1.2.0 нужно
выполнить:

(start code)

$ make install INSTALL_VERSION=1.2.0 LOAD_USERID=testuser/passwd@testdb LOAD_OPERATORID=operator/passwd

(end)

Настройка действий, выполняемых при установке модуля, производится с помощью
изменения DB/Makefile.

Установка обычно состоит из следующих
шагов ( в квадратных скобках указаны соответствующие подцели):
- подготовка к установке [ install-before];
- установка или обновление объектов схемы [ install-schema];
- загрузка программных единиц ( пакетов и т.д.) [ install-load];
- загрузка данных [ install-data];
- загрузка батчей [ install-batch];
- завершение установки [ install-after];
- сохранение информации об установке версии модуля [ install-save-info];

Т.о. установка выполняется достижением соответствующих подцелей.

В рамках подготовки к установке (цель install-before) производится проверка
возможности установки версии модуля на основе данных об установленной версии
модуля, для чего выполняется скрипт <oms-check-install-version.sql>. Например,
в случае установки предыдущей версии (например, 2.4.0 при установленной 2.5.0)
проверка завершится с ошибкой. Отключить проверку можно с помощью параметра
SKIP_FILE_MASK (добавив " SKIP_FILE_MASK=*/oms-check-install-version.sql").

Список остальных скриптов, выполняемых при подготовке к установке, задается в
DB/Makefile в переменной installBeforeTarget с помощью перечисления путей к
файлам ( относительно каталога DB) с дополнительным суффиксом, определяющим,
под каким пользователем файл должен быть выполнен.

Схема задания значений переменной installBeforeTarget аналогична переменной
loadTarget, подробно обсуждавщейся в предыдущем разделе
( <Загрузка файлов в БД>). Основное отличие в том, что вместо суффиксов "$(lu*)"
используются суффиксы "$(ru*)", которые обеспечивают выполнение скрипта при
каждом запуске установки ( в то время как загрузка файлов не выполняется, если
файл не менялся после предыдущей загрузки).

(start code)

installBeforeTarget =                         \
  Install/Config/before-action.sql.$(ru)      \

(end)

В данном примере скрипт DB/Install/Config/before-action.sql будет выполняться
в начале установки для первой схемы загрузки ( LOAD_USERID).

Кроме скриптов, входящих в состав модуля, можно использовать также стандартные
SQL-скрипты, входящие в состав OMS ( указывается только имя с расширением, без
пути).

(start code)

installBeforeTarget =                         \
  Install/Config/before-action.sql.$(ru)      \
  oms-show-invalid.sql.$(ru)                  \
  oms-show-invalid.sql.$(ru2)                 \

(end)

В этом примере в начале установки для первой схемы ( LOAD_USERID) будут
выполнены скрипты DB/Install/Config/before-action.sql и
<oms-show-invalid.sql>, для второй схемы ( LOAD_USERID2) будет выполнен
скрипт <oms-show-invalid.sql>.

Пример универсальной
настройки:

(start code)

installBeforeOmsAction =                      \
  oms-check-lock.sql                          \
  oms-show-invalid.sql                        \

installBeforeTarget =                         \
  $(addsuffix .$(ru),                         \
    $(wildcard Install/Config/$(INSTALL_VERSION)/before-action.sql) \
    $(wildcard Install/Config/before-action.sql) \
    $(installBeforeOmsAction)                 \
  )                                           \
  $(addsuffix .$(ru2),                        \
    $(installBeforeOmsAction)                 \
  )                                           \
  $(addsuffix .$(ru3),                        \
    $(installBeforeOmsAction)                 \
  )                                           \

(end)

В данном случае в начале установки для первой схемы ( LOAD_USERID) выполняются
скрипты DB/Install/Config/$(INSTALL_VERSION)/before-action.sql и
DB/Install/Config/before-action.sql ( в случае их наличия в составе модуля),
для всех схем ( LOAD_USERID, LOAD_USERID2, LOAD_USERID3) выполняются
стандартные действия OMS перед установкой, перечисленные в переменной
installBeforeOmsAction ( в данном случае проверка блокировок на устанавливаемые
объекты скриптом <oms-check-lock.sql> и показ инвалидных объектов скриптом
<oms-show-invalid.sql>). Т.о. в случае необходимости выполнения нестандартных
действий при установке модуля в первую схему ( LOAD_USERID), достаточно создать
соответствующие скрипты в DB/Install/Config ( для действий в других схемах,
нужно создать скрипты и добавить их в installBeforeTarget).

Список объектов, на которые проверяется наличие блокировок, определяется
переменными checkLockTarget и mandatoryCheckLockTarget ( из списка, указанного
в первой переменной, автоматически исключаются объекты, не загружаемые из-за
значений параметров FILE_MASK, LOAD_FILE_MASK и SKIP_FILE_MASK). Формат значений для
этих переменных такой же, как и для loadTarget, по умолчанию значение
checkLockTarget равно loadTarget. Скрипт <oms-check-lock.sql> выполняется
только в случае наличия проверяемых объектов для схем, в которые выполняется
установка.

Для установки объектов схемы ( цель install-schema) выполняются скрипты,
указанные в installSchemaTarget. По умолчанию настроен вызов скипта run.sql из
подкаталога DB/Install/Schema, имя которого определяется значением переменной
INSTALL_VERSION:

(start code)

installSchemaTarget =                   \
  $(addsuffix .$(lu),                   \
    $(wildcard Install/Schema/$(INSTALL_VERSION)/run.sql)  \
  )                                     \
  $(addsuffix .$(lu2),                  \
  )                                     \
  $(addsuffix .$(lu3),                  \
  )                                     \

(end)

При настройке используется загрузка ( суффикс ".$(lu)") вместо выполнения
скриптов ( суффикс ".$(ru)"), т.к. обычно не имеет смысл повторно прогонять
успешно выполненный файл установки схемы ( при желании можно использовать
выполнение вместо загрузки).

Загрузка программных единиц и данных в БД во время установки выполняется при
достижении цели install-load, реализованной с помощью выполнения цели load,
настройка которой подробно описана в предыдущем разделе
( <Загрузка файлов в БД>).

При выполнении загрузки данных ( цель install-data) выполняются скрипты из
подкаталогов каталога DB/Install/Data. Данные для загрузки в конкретную
таблицу могут находиться как в одном скрипте ( расположенном в
DB/Install/Data/Last), так и в нескольких скриптах ( расположенных в
DB/Install/Data/N.N.N). В связи с этим по умолчанию используется следующая
схема:
- загружаются данные из каталога Install/Data/Last;
- дополнительно при установке обновления ( INSTALL_VERSION=N.N.N) загружаются
  данные из каталога Install/Data/N.N.N, а при первоначальной установке
  последней версии ( INSTALL_VERSION=Last) загружаются данные из всех каталогов
  обновлений ( Install/Data/[0-9.]*) в порядке нумерации версий;

В случае отсутствия в каталоге скриптов run.sql и run-after.sql для загрузки
выбираются все скрипты *.sql ( за исключением revert.sql) и *.dat, в противном
случае берутся скрипты run.sql, *.dat, run-after.sql. Порядок загрузки скриптов
можно изменить, указав соответствующие зависимости в файле DB/loaddeps.mk.

Настройка действий при завершении установки ( цель install-after) полностью
аналогична настройке действий перед установкой.

(start code)

installAfterOmsAction =                       \
  oms-compile-invalid.sql                     \

installAfterTarget =                          \
  $(addsuffix .$(ru),                         \
    $(installAfterOmsAction)                  \
    $(wildcard Install/Config/after-action.sql) \
    $(wildcard Install/Config/$(INSTALL_VERSION)/after-action.sql) \
  )                                           \
  $(addsuffix .$(ru2),                        \
    $(installAfterOmsAction)                  \
  )                                           \
  $(addsuffix .$(ru3),                        \
    $(installAfterOmsAction)                  \
  )                                           \

(end)

В данном примере при завершении установки для первой схемы ( LOAD_USERID)
выполняются скрипты DB/Install/Config/$(INSTALL_VERSION)/after-action.sql и
DB/Install/Config/after-action.sql ( в случае их наличия в составе модуля),
для всех схем ( LOAD_USERID, LOAD_USERID2, LOAD_USERID3) выполняются
стандартные действия OMS при завершении установки, перечисленные в переменной
installAfterOmsAction ( компиляция инвалидных объектов скриптом
<oms-compile-invalid.sql>).

Для сохранения в БД информации об установке версии модуля ( подцель
install-save-info) выполняется скрипт <oms-save-install-info.sql>, которому
передаются необходимые параметры ( все настройки сделаны внутри OMS, настройка
в модуле не требуется). Для отключения сохранения информации об установке
версии модуля ( например, если выполняется промежуточная команда установки)
можно исключить выполнение данного скрипта с помощью параметра SKIP_FILE_MASK
( см. ниже).

Также, независимо от сохранения результатов установки, по умолчанию выполняется
сохранение в БД информации по каждому выполняемому скрипту. Это позволяет на
уровне БД получать данные о выполнявшихся скриптах и изменявшихся объектах
в привязке к установкам модулей ( имя и тип изменявшегося объекта определяется
по имени скрипта). Для выполнения вложенных SQL-скриптов желательно
использовать скрипт  <oms-run.sql> вместо встроенных команд "@" и "@@", т.к.
это обеспечивает сохранение в БД информации о вызове скриптов. Логирование на
уровне файлов может быть отключено с помощью параметра
<OMS_SAVE_FILE_INSTALL_INFO>.

В обоих случаях для сохранения информации о выполнении установки используется
модуль ModuleInfo ( SVN root: Oracle/Module/ModuleInfo), который должен быть
установлен в БД. Основную информацию об установках модулей можно увидеть в
представлениях v_mod_install_module, v_mod_install_version и
v_mod_install_object модуля ModuleInfo ( более подробно см. в документации
модуля).

Т.к. для всех шагов установки сделаны отдельные цели, то можно выполнять их
отдельно, например можно выполнить только установку схемы
( без других шагов):

(start code)

$ make install-schema INSTALL_VERSION=Last LOAD_USERID=testuser/passwd@testdb

(end)

Лог каждой установки сохраняется в каталоге DB/OmsModule/Load/Log/Install в
файле с именем

YYYYMMDD_HHMISS[-<moduleName>][-$(INSTALL_VERSION)][-$(dbName)].txt

( имя файла лога выводится в начале выполнения, в качестве имени модуля
<moduleName> берется значение тэга <name> из файла Doc/map.xml).

В случае использования в модуле дополнительных параметров установки, можно
настроить сохранение их значений в логе ( при наличии у них непустых значений).
Для этого нужно перечислить имена дополнительных параметров в переменной
installAddonOptionList в файле DB/Makefile. Например, при использовании
дополнительных параметров установки LOCAL_SCHEMA_DIR и SOURCE_DBLINK нужно
указать:

(start code)

installAddonOptionList =
  LOCAL_SCHEMA_DIR \
  SOURCE_DBLINK \

(end)

Для исключения, задания выполнения/загрузки определенных файлов, можно использовать
параметры FILE_MASK, SKIP_FILE_MASK. Значение параметров представляет собой список
( через пробел или запятую) масок путей к игнорируемым файлам ( аналогично
параметру LOAD_FILE_MASK). Пример:

(start code)

$ make install INSTALL_VERSION=1.2.0 LOAD_USERID=testuser/passwd@testdb SKIP_FILE_MASK=Install/Config/before-action.sql,pkg_TestModule.pkb,*/oms-compile-invalid.sql

(end)

При выполнении установки в случае наличия дополнительных настроечных make-файлов
DB/Install/Config/define.mk или DB/Install/Config/$(INSTALL_VERSION)/define.mk,
они обрабатываются make после основного файла DB/Makefile. Это позволяет
использовать специальные настройки при установке всех либо конкретной версии.
Например, чтобы при установке версии 1.2.0 по-умолчанию пропускались файлы
из предыдущего примера, достаточно создать файл
DB/Install/Config/1.2.0/define.mk со значением параметра SKIP_FILE_MASK:

(start code)

SKIP_FILE_MASK = \
  Install/Config/before-action.sql \
  pkg_TestModule.pkb \
  */oms-compile-invalid.sql

(end)

При этом в случае указания " SKIP_FILE_MASK=..." в строке вызова make
настроенное значение по умолчанию будет перекрыто и использоваться не будет.
Чтобы обеспечить пропуск указанных файлов всегда при установке этой версии
можно использовать директиву override и операцию дополнения значения:

(start code)

override SKIP_FILE_MASK += \
  Install/Config/before-action.sql \
  pkg_TestModule.pkb \
  */oms-compile-invalid.sql

(end)

В этом случае при указании в строке вызова make значения для SKIP_FILE_MASK,
к нему будет добавлено значение по умолчанию, и в итоге будут пропущены все
указанные файлы.


SQL-скрипты, входящие в состав OMS, можно вызывать из собственных SQL-скриптов,
что может быть полезно при настройке установки ( например, именно таким
способом предполагается определять табличное пространство для индексов с
помощью скрипта <oms-set-indexTablespace.sql>), подробнее см. в
<Запуск oms-скриптов>.

Для вызова из одного скрипта модуля других скриптов, входящих в состав модуля и
не находящихся в той же директории, что и исходный скрипт, нужно указывать эти
скрипты с путем относительно каталога DB ( т.к. при выполнении скриптов текущим
является этот каталог). Например, чтобы вызвать из скрипта run.sql установки
схемы версии 2.0.0 ( DB/Install/Schema/2.0.0/run.sql) скрипт создания
таблицы tmp_table.tab, находящийся в DB/Install/Schema/Last, в run.sql
нужно добавить строку:

(start code)

@Install/Schema/Last/tmp_table.tab

(end)

Для задания специальных параметров установки можно при вызове make указывать
параметр SQL_DEFINE. Он представляет собой список значений переменных SQL*Plus,
которые создаются командой define перед выполнением/загрузкой файлов. Список
указывается в формате name=value[,name2=value2]..., для экранирования
разделителя может использоваться обратный слэш, при наличии пробелов нужно
заключать список в кавычки. Пробелы в части имени, а также начальные и конечные
пробелы в части значения, игнорируются, для добавления начальных или конечных
пробелов в значение нужно использовать кавычки ( например,
SQL_DEFINE="name1 = \" a \, b\", name2=c" задает переменную name1 со значением
" a , b"  и переменную name2 со значением "c"). Пример задания имени табличного
пространства для индексов через переменную indexTablspace:

(start code)

$ make install INSTALL_VERSION=Last LOAD_USERID=testuser/passwd@testdb SQL_DEFINE=indexTablespace=INDX

(end)

С помощью переменной loadArgumentList можно настроить передачу параметров
загружаемому/выполняемому SQL-скрипту. Для этого в переменную нужно добавить
строку вида
  $(call getArgumentDefine,<filePath>.$([l,r]u*),"arg1"[ "arg2"]...)
, где filePath путь к файлу относительно каталога DB ( с учетом регистра, можно использовать метасимволы). С помощью дополнительного расширения ( например,
$(lu2)) определяется схема и тип загрузки файла, для которой используются
параметры ( если для любых, то можно указать *). Например, для передачи скрипту
установки схемы номера устанавливаемой версии модуля в качестве первого
параметра, нужно настроить:

(start code)

loadArgumentList += \
  $(call getArgumentDefine,Install/Schema/*/run.sql.*,"$(INSTALL_VERSION)")

(end)

По умолчанию выполнение/загрузка SQL-скрипта через OMS прерывается при
возникновении ошибки. Чтобы выполнить скрипты ( и всю установку) до конца
с игнорированием ошибок, можно использовать опцию --ignore-errors ( сокращение
-i) при вызове make:

(start code)

$ make -i install INSTALL_VERSION=1.2.0 LOAD_USERID=testuser/passwd@testdb

(end)



Group: Загрузка батчей модуля Scheduler в БД

*Загрузка батчей в БД* реализована в OraMakeSystem с помощью вызовов
процедур модуля Scheduler ( пакет pkg_SchedulerLoad), данные для которых
берутся из данных локальных файлов модуля ( *.job.sql, batch.xml,
batch_config.xml);

Отдельная установка ( обновление) только батчей модуля в БД выполняется с
помощью вызова make с целью install-batch. Например,


(start code)

$ make install-batch LOAD_USERID=testuser/passwd@testdb LOAD_OPERATORID=operator/passwd

(end)


Для установки батчей ( цель install-batch) выполняются скрипты,
указанные в installBatchTarget. При загрузке job уровни видимости
определяются в завимости от расположения файлов *.job.sql
( наличия batch.xml в той же директории или по названию родительской директории
PublicJob);


(start code)

installBatchTarget = \
  $(addsuffix .$(ru), \
    $(wildcard Install/Batch/Last/*.job.sql) \
    $(wildcard Install/Batch/Last/*/*.job.sql) \
    $(wildcard Install/Batch/Last/*/batch.xml) \
  )
  $(addsuffix .$(ru2), \
  ) \
  $(addsuffix .$(ru3), \
  ) \

(end)

Использование суффиксов ".$(lu)" и ".$(ru)" аналогично использованию
для других скриптов ( например, из installSchemaTarget);

Для подробностей по созданию файлов для загрузки батчей см. автодокументацию к
модулю Scheduler ( SVN root: Oracle/Module/Scheduler).



Group: Отмена установки модуля в БД

Отмена установки ( обновления) модуля в БД выполняется с помощью вызова make с
целью uninstall с указанием версии модуля, а также параметров подключения к БД
и логина оператора, выполняющего операцию. Например, для
удаления последней версии модуля из БД нужно выполнить:

(start code)

$ make uninstall INSTALL_VERSION=Last LOAD_USERID=testuser/passwd@testdb LOAD_OPERATORID=operator/passwd

(end)

Аналогично, для отмены обновления модуля до версии 1.2.0 нужно
выполнить:

(start code)

$ make uninstall INSTALL_VERSION=1.2.0 LOAD_USERID=testuser/passwd@testdb LOAD_OPERATORID=operator/passwd

(end)

Настройка действий, выполняемых при отмене установки модуля, производится с
помощью изменения DB/Makefile и аналогична настройке действий при установке
( см. <Установка модуля в БД>).

Отмена установки обычно состоит из следующих
шагов ( в квадратных скобках указаны соответствующие подцели):
- подготовка к отмене установки [ uninstall-before];
- отмена изменений в объектах схемы [ uninstall-schema];
- загрузка предыдущих версий программных единиц ( пакетов и т.д.)
  [ uninstall-load];
- отмена изменений в данных, внесенных при установке [ uninstall-data];
- завершение отмены установки [ uninstall-after];
- сохранение информации об отмене установки модуля [ uninstall-save-info];

Т.о. отмена установки выполняется достижением соответствующих подцелей.

В рамках подготовке к отмене установки (цель uninstall-before) производится
проверка возможности отмены установки версии модуля на основе данных об
установленной версии модуля, для чего выполняется скрипт
<oms-check-uninstall-version.sql>. Отключить проверку можно с помощью
параметра SKIP_FILE_MASK (добавив
" SKIP_FILE_MASK=*/oms-check-uninstall-version.sql").

Список остальных скриптов, выполняемых при подготовке к отмене установки
задается в DB/Makefile в переменной uninstallBeforeTarget аналогично заданию
действий перед установкой в installBeforeTarget ( см.  предыдущий раздел), при
этом по умолчанию выполняются скрипты из каталога DB/Install/Config и
DB/Install/Config/$(INSTALL_VERSION)/Revert:

(start code)

uninstallBeforeOmsAction = \
  oms-check-lock.sql \
  oms-show-invalid.sql \


uninstallBeforeTarget = \
  $(addsuffix .$(ru), \
    $(if $(INSTALL_VERSION), \
      $(wildcard Install/Config/$(INSTALL_VERSION)/Revert/before-action.sql),) \
    $(wildcard Install/Config/before-action.sql) \
    $(uninstallBeforeOmsAction) \
  ) \
  $(addsuffix .$(ru2), \
    $(uninstallBeforeOmsAction) \
  ) \
  $(addsuffix .$(ru3), \
    $(uninstallBeforeOmsAction) \
  ) \

(end)

Список объектов, на которые проверяется наличие блокировок, определяется
переменными uninstallCheckLockTarget и mandatoryCheckLockTarget ( из списка,
указанногов первой переменной, автоматически исключаются объекты, не
загружаемые из-за значения параметра SKIP_FILE_MASK). По умолчанию на наличие
блокировок проверяются загружаемые по uninstall-load объекты ( т.е.
uninstallCheckLockTarget равно uninstallLoadTarget). В случае, если нет объектов
для проверки блокировок, скрипт <oms-check-lock.sql> не выполняется.



Для отмены изменений в объектах схемы ( цель uninstall-schema) выполняются
скрипты, указанные в uninstallSchemaTarget. По умолчанию настроен вызов скипта
revert.sql из подкаталога DB/Install/Schema, имя которого определяется
значением переменной INSTALL_VERSION:

(start code)

uninstallSchemaTarget = \
  $(addsuffix .$(ru), \
    $(wildcard Install/Schema/$(INSTALL_VERSION)/revert.sql) \
  ) \
  $(addsuffix .$(ru2), \
  ) \
  $(addsuffix .$(ru3), \
  ) \

(end)



Скрипты, выполняемые для загрузки предыдущих версий программных единиц ( цель
uninstall-load), определяются переменной uninstallLoadTarget. По умолчанию
загружаются все скрипты с соответствующими расширениями из каталога
DB/Install/Schema/$(INSTALL_VERSION)/Revert:

(start code)

uninstallLoadTarget = \
  $(addsuffix .$(ru), \
    $(if $(INSTALL_VERSION), \
      $(foreach m, *.typ *.vw *.pks *.trg *.tyb *.pkb, \
        $(wildcard Install/Schema/$(INSTALL_VERSION)/Revert/$(m)) \
      ) \
    ,) \
  ) \
  $(addsuffix .$(ru2), \
  ) \
  $(addsuffix .$(ru3), \
  ) \

(end)

Правильную последовательность выполнения скриптов можно обеспечить, указав
зависимости между выполняемыми скриптами в файле DB/loaddeps.mk
( см. <Загрузка файлов в БД>). Каталоги DB/Install/Schema/*/Revert исключены
из автогенерации документации, т.к. там находятся файлы из предыдущей версии
модуля.



Для отмены изменений в данных ( цель uninstall-data) выполняются скрипты,
заданные в uninstallDataTarget. По умолчанию выполняется скрипт revert.sql
из каталога DB/Install/Data/$(INSTALL_VERSION):

(start code)

uninstallDataTarget = \
  $(addsuffix .$(ru), \
    $(wildcard Install/Data/$(INSTALL_VERSION)/revert.sql) \
  ) \
  $(addsuffix .$(ru2), \
  ) \
  $(addsuffix .$(ru3), \
  ) \

(end)



Настройка действий при завершении отмены установки ( цель uninstall-after)
аналогична настройке действий перед отменой установки ( см. выше):

(start code)

uninstallAfterOmsAction = \
  oms-compile-invalid.sql \


uninstallAfterTarget = \
  $(addsuffix .$(ru), \
    $(uninstallAfterOmsAction) \
    $(wildcard Install/Config/after-action.sql) \
    $(if $(INSTALL_VERSION), \
      $(wildcard Install/Config/$(INSTALL_VERSION)/Revert/after-action.sql),) \
  ) \
  $(addsuffix .$(ru2), \
    $(uninstallAfterOmsAction) \
  ) \
  $(addsuffix .$(ru3), \
    $(uninstallAfterOmsAction) \
  ) \

(end)

Для сохранения в БД информации об отмене установке версии модуля ( подцель
uninstall-save-info) выполняется скрипт <oms-save-uninstall-info.sql>, которому
передаются необходимые параметры ( аналогично подцели install-save-info).
При этмо в случае выполнения отмены установки конкретной версии модуля
( параметр INSTALL_VERSION не равен Last), необходимо явно указывать версию
модуля, получающуюся в БД после отмены установки, с помощью параметра
<UNINSTALL_RESULT_VERSION>:

(code)

$ make uninstall INSTALL_VERSION=1.3.0 UNINSTALL_RESULT_VERSION=1.2.0 LOAD_USERID=testuser/passwd@testdb LOAD_OPERATORID=operator/passwd

(end)

Отмена установки логируется, лог сохраняется в каталоге
DB/OmsModule/Load/Log/Install в файле с именем

YYYYMMDD_HHMISS[-<moduleName>]-uninstall[-$(INSTALL_VERSION)][-$(dbName)].txt

( имя файла лога выводится в начале выполнения, в качестве имени модуля
<moduleName> берется значение тэга <name> из файла Doc/map.xml).

Как и в случае установки, для исключения выполнения/загрузки определенных
файлов можно использовать параметры FILE_MASK, SKIP_FILE_MASK.

Также, аналогично установке, при выполнении отмены установки в случае наличия
дополнительных настроечных make-файлов DB/Install/Config/define.mk или
DB/Install/Config/$(INSTALL_VERSION)/Revert/define.mk, они обрабатываются make
после основного файла DB/Makefile.



Group: Выдача прав пользователям БД

Выдача прав пользователям БД выполняется с помощью вызова make с целью
grant с указанием в параметре TO_USERNAME пользователя, которому выдаются права,
а также параметров подключения к БД. Например, для выдачи пользователю
testUser2 прав на использование модуля, нужно выполнить:

(start code)

$ make grant LOAD_USERID=testuser/passwd@testdb LOAD_OPERATORID=operator/passwd TO_USERNAME=testUser2

(end)


Можно также задать имя скрипта для выдачи прав с помощью параметра GRANT_SCRIPT
( по умолчанию run.sql, расширение ".sql" можно не указывать) и версию скрипта
с помощью параметра INSTALL_VERSION ( по умолчанию Last). Например, для выдачи
пользователю дополнительных прав для доступа по чтению, добавленных в версии
1.2.0, нужно выполнить ( предполагается наличие скрипта
DB/Install/Grant/1.2.0/read-only.sql в составе модуля):

(start code)

$ make grant INSTALL_VERSION=1.2.0 LOAD_USERID=testuser/passwd@testdb LOAD_OPERATORID=operator/passwd TO_USERNAME=testUser2 GRANT_SCRIPT=read-only

(end)

Выдача прав состоит из следующих
шагов ( в квадратных скобках указаны соответствующие подцели):
- выполнение выдачи прав [ grant-exec];
- сохранение информации о выполненной выдаче прав [ grant-save-info];

Настройка действий, выполняемых для выдачи прав, производится с помощь
изменения переменной grantTarget в файле DB/Makefile ( аналогично, например,
настройке действий перед установкой в <Установка модуля в БД>). При выполнении
скриптам, указанным в grantTarget, в качестве первого параметра передается
имя пользователя из TO_USERNAME.

Перед выдачей прав производится проверка возможности выдачи прав на основе
данных об установленной версии модуля, для чего выполняется скрипт
<oms-check-grant-version.sql>. Отключить проверку можно с помощью параметра
SKIP_FILE_MASK (добавив " SKIP_FILE_MASK=*/oms-check-grant-version.sql").

Для сохранения в БД информации о выдаче прав ( подцель grant-save-info)
выполняется скрипт <oms-save-grant-info.sql>, которому передаются необходимые
параметры ( все аналогично подцели install-save-info установки).

Лог выдачи прав сохраняется в каталоге DB/OmsModule/Load/Log/Install в
файле с именем

YYYYMMDD_HHMISS[-<moduleName>]-grant[-$(INSTALL_VERSION)][-$(dbName)].txt

( имя файла лога выводится в начале выполнения, в качестве имени модуля
<moduleName> берется значение тэга <name> из файла Doc/map.xml).



Group: Выполнение SQL-скриптов

SQL-скрипты, входящие в состав OMS ( файлы SqlScript/oms-*.sql) можно вызывать
из собственных SQL-скриптов, выполняемых через OMS. Например, для определения
имени табличного пространства для индексов можно вызвать скрипт
<oms-set-indexTablespace.sql> из скрипта DB/Install/Schema/Last/run.sql,
входящего в состав модуля:

(start code)

...

@oms-set-indexTablespace.sql

...

(end)

Чтобы этот вызов работал не только при выполнении через OMS, а всегда
при выполнении скрипта DB/Install/Schema/Last/run.sql из SQL*Plus, достаточно
добавить путь к каталогу с OMS-скриптами
( "D:\OraMakeSystem\usr\local\share\oms\SqlScript" в случае стандартной
установки для Windows либо "C:\cygwin\usr\local\share\oms\SqlScript" при
стандартной установке для Cygwin) в переменную окружения SQLPATH.



Group: Прикладные SQL-скрипты

В состав OMS входят прикладные SQL-скрипты, предназначенные для использования
из пользовательских скриптов. С помощью них можно проще выполнять операции,
часто встречающиеся в различных модулях.

Скрипты по назначению:

- настройка параметров установки;

  Для задания параметров установки удобно применять макропеременные SQL*Plus,
  которым задаются значения по умолчанию. В случае необходимости при выполнении
  установки вместо значения по умолчанию для макропеременной может быть задано
  другое значение с помощью параметра <SQL_DEFINE>.

  К скриптам данной группы
  относятся:
  <oms-default.sql>           - задание макропеременной значения по умолчанию;
  <oms-default-with-test.sql> - задание макропеременной значения по умолчанию
                                для тестовой и промышленной БД;
  <oms-get-db-link.sql>       - определение используемого по умолчанию линка;
  <oms-set-indexTablespace.sql>   - определение используемого по умолчанию
                                    табличного пространства для индексов;
  <oms-set-lobTablespace.sql> - определение используемого по умолчанию
                                табличного пространства для полей типа LOB;

- выполнение вложенных SQL-скриптов;

  При выполнении большого числа действий в SQL-скрипте часто бывает удобно
  разбить их на отдельные логические части и использовать для каждой части
  отдельные SQL-скрипты, последовательно вызываемые из основного скрипта.
  Такая ситуация обычно возникает при написании скрипта для установки или
  обновления объектов схемы ( DB/Install/Schema/*/run.sql). Однако при этом
  по логу выполнения установки становится затруднительно определить, на каком
  этапе находится установка или место, где произошла ошибка ( т.к. нужно
  последовательно просматривать исходники всех вложенных скриптов).

  Для решения этой проблемы в основном скрипте вместо стандартной команды
  выполнения скрипта "@@" ( или "@") можно использовать скрипт <oms-run.sql>,
  который выводит информацию о скрипте перед его выполнением. Скрипт
  <oms-run.sql> также учитывает значение параметров <SKIP_FILE_MASK>, <FILE_MASK> и
  не запускает скрипты, которые должны игнорироваться согласно этим параметрам.
  Это можно использовать для тестирования отдельных частей установки.

- выполнение операций над объектам БД;

  Данные скрипты упрощают выполнение операций
  над объектами БД:
  <oms-drop-type.sql>         - принудительное удаление SQL-типа, от которого
                                зависят другие объекты ( применяется перед
                                пересозданием типа во время установки);
  <oms-gather-stats.sql>      - сбор статистики по таблице или
                                материализованному представлению;
  <oms-refresh-mview.sql>     - обновление материализованного представления
                                и сбор по нему статистики;

- управление пакетными заданиями, реализованными с помощью модуля Scheduler;

  Скрипты для управления
  пакетными заданиями:
  <oms-activate-batch.sql>    - активация пакетных заданий;
  <oms-deactivate-batch.sql>  - деактивация пакетных заданий;
  <oms-reactivate-batch.sql>  - повторная активация пакетных заданий;
  <oms-resume-batch.sql>      - повторная активация пакетных заданий с
                                ожиданием запуска заданий, которые должны
                                начать выполняться;
  <oms-stop-batch.sql>        - деактивация пакетных заданий с ожиданием
                                завершения сессий выполняющихся пакетных
                                заданий;

  Например, при выполнении установки прикладных модулей часто требуется
  временно приостановить выполнение связанных с модулем процессов,
  реализованных в виде пакетных заданий. Для этого можно воспользоваться
  скриптами <oms-stop-batch.sql> и <oms-resume-batch.sql>,
  вызываемыми соответственно в начале и при завершении установки.

- вспомогательные скрипты;

  Скрипт <oms-init-var.sql> обеспечивает возможность использования большинства
  SQL-скриптов, входящих в OMS, в интерактивной сессии SQL*Plus.
