create or replace and compile java source named "NetFile" as
//
// DO NOT EDIT: Autogenerated from java class source files.
//

package ru.company.netfile;

import com.enterprisedt.net.ftp.FTPClient;
import com.enterprisedt.net.ftp.FTPClientInterface;
import com.enterprisedt.net.ftp.FTPConnectMode;
import com.enterprisedt.net.ftp.FTPException;
import com.enterprisedt.net.ftp.FTPFile;
import com.enterprisedt.net.ftp.FTPFileFactory;
import com.enterprisedt.net.ftp.FTPInputStream;
import com.enterprisedt.net.ftp.FTPOutputStream;
import com.enterprisedt.net.ftp.FTPTransferType;
import com.enterprisedt.net.ftp.UnixFileParser;
import com.enterprisedt.net.ftp.WindowsFileParser;
import com.enterprisedt.net.ftp.ssh.SSHFTPClient;
import com.enterprisedt.net.ftp.ssh.SSHFTPInputStream;
import com.enterprisedt.net.ftp.ssh.SSHFTPOutputStream;
import com.enterprisedt.util.debug.Level;
import com.enterprisedt.util.debug.Logger;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Reader;
import java.io.Writer;
import java.math.BigDecimal;
import java.net.URL;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.Security;
import java.sql.*;
import java.util.Arrays;
import java.util.Locale;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;
import org.apache.http.HttpEntity;
import org.apache.http.HttpHost;
import org.apache.http.HttpResponse;
import org.apache.http.StatusLine;
import org.apache.http.auth.AuthScope;
import org.apache.http.auth.NTCredentials;
import org.apache.http.client.CredentialsProvider;
import org.apache.http.client.HttpResponseException;
import org.apache.http.client.config.AuthSchemes;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpHead;
import org.apache.http.client.protocol.HttpClientContext;
import org.apache.http.impl.client.BasicCredentialsProvider;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import ru.company.netfile.ReaderInputStream;
import ru.company.netfile.WriterOutputStream;



/** class: ArrayInputStream
 * Класс для представления массива байтов в виде потока ввода.
 * Расширяет возможности стандартного класса java.io.ByteArrayInputStream,
 * позволяя менять параметры массива-источника.
 **/
public class ArrayInputStream extends ByteArrayInputStream
{

  /** func: ArrayInputStream
   * Создает объект и передает параметры конструктору суперкласса.
   **/
  public ArrayInputStream( byte[] buf)
  {
    super( buf);
  }

  /** proc: setCount
   * Устанавливает число доступных для чтения элементов массива.
   **/
  public void setCount( int count)
  {
    this.count = count;
  }

  /** func: getBuffer
   * Возвращает текущий массив-источник.
   **/
  public byte[] getBuffer()
  {
    return ( this.buf);
  }

  /** proc: setBuffer
   * Устанавливает массив-источник.
   **/
  public void setBuffer( byte[] buf)
  {
    this.buf = buf;
    setCount( buf.length);
  }

}




/** class: ArrayOutputStream
 * Класс для представления массива байтов в виде потока вывода.
 * Расширяет возможности стандартного класса java.io.ByteArrayOutputStream,
 * позволяя устанавливать массив назначения.
 **/
public class ArrayOutputStream extends ByteArrayOutputStream
{

  /** func: ArrayOutputStream
   * Создает объект без распределения буферного массива.
   **/
  public ArrayOutputStream()
  {
    super( 0);
  }



  /** func: getCount
   * Возвращает число заполненных элементов массива.
   **/
  public int getCount()
  {
    return ( count);
  }



  /** func: getBuffer
   * Возвращает текущий массив назначения.
   **/
  public byte[] getBuffer()
  {
    return ( buf);
  }



  /** proc: setBuffer
   * Устанавливает массив назначения.
   **/
  public void setBuffer( byte[] buf, int off)
  {
    this.buf = buf;
    this.count = off;
  }

}



/** class: FileClass
 * Классы файлов ( каждому классу соответствует собственный подкласс
 * класса <NetFileImpl>)
 */
class FileClass {

  /** const: FS
   * Файл файловой системы
   **/
  public static final FileClass FS = new FileClass();

  /** const: FTP
   * Файл доступный по FTP ( или SFTP)
   **/
  public static final FileClass FTP = new FileClass();

  /** const: HTTP
   * Файл доступный по HTTP
   **/
  public static final FileClass HTTP = new FileClass();



  /** func: FileClass
   * Конструктор для предотвращения некорректного создания объектов
   **/
  private FileClass() {
  }



  /** func: getFileClass
   * Возвращает класс файла, соответствующий указанному пути ( URL).
   *
   * Параметры:
   * path                     - путь ( или URL) к файлу
   **/
  public static FileClass getFileClass( String path)
  {
    return
      path.startsWith( "ftp://") || path.startsWith( "sftp://")
        ? FTP
      : path.startsWith( "http://")
        ? HTTP
      : FS
    ;
  }



  /** func: makeNetFileImpl
   * Создает и возвращает объект для работы с файлом.
   *
   * Параметры:
   * path                     - путь ( или URL) к файлу
   **/
  public NetFileImpl makeNetFileImpl( String path)
    throws
      IOException
      , FTPException
      , java.sql.SQLException
  {
    return
      this == FS
        ? new FsFile( path)
      : this == FTP
        ?  new FtpFile( path)
      : this == HTTP
        ? new HttpFile( path)
      : null
    ;
  }

}



/** class: FileInfo
 * Содержит информацию о файле ( абстрактный класс).
 */
abstract public class FileInfo
{

  /** func: name
   * Имя файла.
   **/
  abstract public String name();

  /** func: isFile
   * Возвращает истину, если файл является регулярным файлом.
   **/
  abstract public boolean isFile();

  /** func: isDirectory
   * Возвращает истину, если файл является каталогом.
   **/
  abstract public boolean isDirectory();

  /** func: length
   * Размер файла в байтах.
   **/
  abstract public long length();

  /** func: lastModified
   * Дата последней модификации.
   **/
  abstract public java.util.Date lastModified();

};



/** class: FileType
 * Класс для перечисления распознаваемых типов файлов
 */
class FileType {

  /** const: FILE
   * Обычный регулярный файл
   **/
  public static final FileType FILE       = new FileType();

  /** const: DIRECTORY
   * Каталог
   **/
  public static final FileType DIRECTORY  = new FileType();

  /** const: UNKNOWN
   * Файл неизвестного типа
   **/
  public static final FileType UNKNOWN    = new FileType();



  /** func: FileType
   * Конструктор для предотвращения некорректного создания объектов
   **/
  private FileType() {
  }

}



/** class: FsFile
 * Класс для работы с файлами файловой системы ( локальными и UNC)
 * ( подкласс класса <NetFileImpl>).
 *
 * Методы реализованы с помощью соответсвующих методов java.io.File.
 */
class FsFile extends NetFileImpl {

  /** const: READ_BUFFER_SIZE
   * Размер буфера для чтения файла
   **/
  final private static int READ_BUFFER_SIZE = 1024 * 16;

  /** const: WRITE_BUFFER_SIZE
   * Размер буфера для записи в файл
   **/
  final private static int WRITE_BUFFER_SIZE = 1024 * 16;

  /** var: logger
   * Логгер класса
   **/
  private static java.util.logging.Logger logger =
    java.util.logging.Logger.getLogger( "ru.company.netfile.FsFile")
  ;

  /** var: file_
   * Файл файловой системы
   **/
  private java.io.File file_;



  /** func: FsFile
   * Создает объект для работы с файлом по полному пути (локальному или UNC)
   */
  public FsFile( java.lang.String path)
  {
    file_ = new java.io.File( path);
  }



  /** func: getPath
   * Возвращает путь до файла.
   */
  final public String getPath()
  {
    return ( file_.getPath());
  }



  /** func: getName
   * Возвращает имя файла.
   */
  final public String getName()
  {
    return ( file_.getName());
  }



  /** func: checkState
   * Обновляет информацию о файле и возвращет его тип либо null, если файл не
   * существует.
   */
  public FileType checkState()
    throws IOException
  {
    FileType fileType = null;
    if ( file_.exists()) {
      fileType =
        file_.isFile()       ? FileType.FILE :
        file_.isDirectory()  ? FileType.DIRECTORY
                             : FileType.UNKNOWN
      ;
    }
    return ( fileType);
  }


  /** func: dir
   * Возвращает массив с информацией о файлах каталога или null, если файл не
   * является каталогом либо не существует.
   */
  public FileInfo[] dir()
    throws IOException
  {
    FileInfo[] infos = null;
    File[] files = file_.listFiles();
    if( files != null) {
      infos = new FileInfo[ files.length];
      for( int i = 0; i < infos.length; ++i)
        infos[ i] = new FsFileInfo( files[ i]);
    }
    return ( infos);
  }


  /** func: getInputStream
   * Возвращает поток для чтения из файла
   */
  public InputStream getInputStream()
    throws IOException
  {
     return new FileInputStream( file_.getPath());
  }

  /** func: getOutputStream
   * Возвращает поток для записи в файл
   */
  public OutputStream getOutputStream(boolean append)
    throws IOException
  {
     return new FileOutputStream( file_.getPath(), append);
  }


  /** proc: copy
   * Копирует файл
   */
  public void copy( String toPath, boolean overwrite)
    throws IOException
  {
    File newPath = new File( toPath);

    // Добавляем имя при копировании в каталог
    if( newPath.isDirectory())
      newPath = new File( newPath, file_.getName());

    if( newPath.exists()) {
      if( !overwrite) {
        throw new java.lang.IllegalArgumentException(
          "Destination file '" + newPath.getPath() + "' already exist"
          );
      }
    }
    FileInputStream src = new FileInputStream( file_);
    int size = 0;
    try {
      FileOutputStream dst = new FileOutputStream( newPath);
      try {
        byte buffer[] = new byte[ READ_BUFFER_SIZE];
        int count;
        while( ( count = src.read( buffer)) != -1) {
          dst.write( buffer, 0, count);
          size += count;
        }
      }
      finally {
        dst.close();
      }
    }
    finally {
      src.close();
    }
    logger.fine(
      "copied file: '"
      + file_.getPath() + "' -> '" + newPath.getPath()
      + "' ( " + size + " bytes)"
    );
  }



  /** proc: delete
   * Удаляет файл
   */
  public void delete()
    throws IOException
  {
    if( !file_.delete()) {                //Удаляем файл
      throw new java.io.IOException(      //Исключение при неуспешном удалении
        "File '" + file_.getPath() + "' not deleted"
        );
    }
    logger.fine( "deleted file: " + file_.getPath());
  }



  /** proc: renameTo
   * Пытается выполнить переименование файла.
   *
   * Параметры:
   * toPath                   - новый путь ( URL) к файлу
   * overwrite                - признак перезаписи файла
   *
   * Возврат:
   * true                     - в случае успеха
   * false                    - в случае неудачи
   */
  public boolean renameTo( String toPath, boolean overwrite)
    throws IOException, FTPException
  {
    boolean isOk = false;
    File newPath = new File( toPath);

    // Добавляем имя при копировании в каталог
    if( newPath.isDirectory())
      newPath = new File( newPath, file_.getName());

    if( newPath.exists()) {
      if( ! overwrite)
        throw new java.lang.IllegalArgumentException(
          "Destination file '" + newPath.getPath() + "' already exist"
          );
      else if( ! newPath.delete())
        throw new java.io.IOException(
          "Destination file '" + newPath.getPath() + "' not deleted"
        );
      logger.fine( "exists destination file deleted: " + newPath.getPath());
    }

    isOk = file_.renameTo( newPath);
    logger.fine(
      "rename result: " + isOk
      + " ( '" + file_.getPath() + "' -> '" + newPath.getPath() + "')"
    );

    return isOk;
  }



  /** proc: makeDirectory
   * Создаёт директорию
   *
   * raiseException           - флаг генерации исключения в случае
   *                            существования или отсутствия родительской
   *                            директории
   **/
  public void makeDirectory( boolean raiseException)
    throws IOException
  {
    if ( raiseException) {
      if ( !file_.mkdir()) {
        throw new java.io.IOException(
          // Исключение при неуспешном удалении
          "Could not create directory: '" + file_.getPath() + '"'
        );
      }
      logger.fine( "make directory: " + file_.getPath());
    } else {
      boolean isOk = file_.mkdirs();
      logger.fine(
        "make directories result: " + isOk + " ( '" + file_.getPath() + "')"
      );
    }
  }

} // FsFile




/** class: FsFileInfo
 * Содержит информацию о файле
 * ( подкласс класса <FileInfo>)
 */
final class FsFileInfo extends FileInfo
{

  /** var: file_
   * Информация о файле.
   **/
  private File file_;



  /** func: FsFileInfo
   * Создает новый объект на основе файла.
   */
  public FsFileInfo( File file)
  {
    file_ = file;
  }



  /** func: name
   * Имя файла.
   **/
  public String name()
  {
    return ( file_.getName());
  }



  /** func: isFile
   * Возвращает истину, если файл является регулярным файлом.
   **/
  public boolean isFile()
  {
    return ( file_.isFile());
  }



  /** func: isDirectory
   * Возвращает истину, если файл является каталогом.
   **/
  public boolean isDirectory()
  {
    return ( file_.isDirectory());
  }



  /** func: length
   * Размер файла в байтах.
   **/
  public long length()
  {
    return ( file_.length());
  }



  /** func: lastModified
   * Дата последней модификации.
   **/
  public java.util.Date lastModified()
  {
    return ( new java.util.Date( file_.lastModified()));
  }

}










/** class: FtpFile
 * Класс для работы с файлами через FTP
 * ( базовый класс <NetFileImpl>).
 *
 * Работа через FTP реализована с помощью библиотеки <edtFTPj>.
 */
class FtpFile extends NetFileImpl {

  /** const: TCP_TIMEOUT
   * TCP таймаут
   **/
  final public static int TCP_TIMEOUT = 60 * 1000;

  /** const: DEFAULT_USER
   * Имя пользователя по умолчанию
   **/
  final private static String DEFAULT_USER = "anonymous";

  /** const: DEFAULT_PASSWORD
   * Пароль по умолчанию
   **/
  final private static String DEFAULT_PASSWORD = "ftp";

  /** const: REPLAY_NOT_EXIST_PREFIX
   * Первые две цифры ошибки выполнения CWD на несуществующий каталог
   **/
  final private static int REPLAY_NOT_EXIST_PREFIX = 55;

  /** const: OS400_SYSTEM_PREFIX
   * Префикс в строке информации о системе для OS/400
   **/
  final private static String OS400_SYSTEM_PREFIX = "OS/400";

  /** const: MSFTPS_SYSTEM
   * Имя системы для Microsoft FTP Service
   **/
  final private static String MSFTPS_SYSTEM = "XXXXXXXXXX";



  /** var: baseUrl_
   * Исходный URL файла.
   **/
  protected String baseUrl_;

  /** var: url_
   * Разобранный URL файла.
   * В связи с отсутствием поддержки в классе java.net.URL, протокол SFTP
   * подменяется на FTP.
   **/
  protected java.net.URL url_;

  /** var: path_
   * Локальный путь к файлу
   **/
  protected String path_;

  /** var: dirPath_
   * Путь к локальному каталогу, содержащему файл
   **/
  protected String dirPath_;

  /** var: name_
   * Имя файла
   **/
  protected String name_;

  /** var: isSftp_
   * Используется ли SFTP
   **/
  protected boolean isSftp_;

  /** var: ftp_
   * Интерфейс к клиенту для работы с FTP
   **/
  protected FTPClientInterface ftp_;

  /** var: sftpClient_
   * Клиент для работы по SFTP
   **/
  protected SSHFTPClient sftpClient_;

  /** var: ftpClient_
   * Клиент для работы с FTP
   **/
  protected FTPClient ftpClient_;

  /** var: fileFactory_
   * Парсер для разбора листинга с FTP
   **/
  protected FTPFileFactory fileFactory_;



  /** func: FtpFile
   * Создает объект по полному пути ( ftp://[user[:password]@]host[/path] )
   */
  public FtpFile( java.lang.String path)
    throws IOException, FTPException, java.net.MalformedURLException
  {
                                        // Логгирование для SFTP
    // Logger log = Logger.getLogger( "");
    // Logger.setLevel( Level.DEBUG);
    baseUrl_ = path;
                                        // Разбор URL
    isSftp_ = path.startsWith( "sftp://");
    url_ = new java.net.URL( isSftp_ ? path.substring( 1) : path);
                                        // Определяем каталог и имя файла
    dirPath_ = url_.getPath();          // Получаем путь до файла
    if( dirPath_.startsWith( "/"))      // Удаляем начальный разделитель
      dirPath_ = dirPath_.substring( 1);
                                        // Удаляем незначимый разделитель
    if( dirPath_.endsWith( "/"))
      if( dirPath_.length() > 1)
        dirPath_ = dirPath_.substring( 0, dirPath_.length() - 1);
    path_ = dirPath_;                   // Сохраняем путь до файла
    if( dirPath_.length() != 0) {       // Выделяем имя, если оно задано
                                        // Разделяем имя и родительский каталог
      int iSep = dirPath_.lastIndexOf( '/');
      name_ = dirPath_.substring( iSep + 1);
      if( name_.equals( ".") || name_.equals( ".."))
        name_ = "";
      else
        dirPath_ = iSep != -1 ? dirPath_.substring( 0, ( iSep > 0 ? iSep : 1))
                   : "";
    }
    else
      name_ = "";
    String user, password;              // Определяем пользователя/пароль
    String userInfo = url_.getUserInfo();
    int len = userInfo.length();
    if( len > 0) {
      int iSep = userInfo.indexOf( ":");
      if( iSep != -1) {
        user = userInfo.substring( 0, iSep);
        password = userInfo.substring( iSep + 1);
      }
      else {
        user = userInfo;
        password = DEFAULT_PASSWORD;
      }
    }
    else {
      user = DEFAULT_USER;
      password = DEFAULT_PASSWORD;
    }
                                        // Подключаемся к серверу
    if( isSftp_) {
      checkSecurityAlgorithm();
      sftpClient_ = connectSftp( user, password);
      ftp_ = sftpClient_;
    }
    else {
      ftpClient_ = connectFtp( user, password);
      ftp_ = ftpClient_;
    }
                                        // Устанавливаем параметры соединения
    ftp_.setType( FTPTransferType.BINARY);
    ftp_.setDetectTransferMode( false);
  }



  /** func: getPath
   * Возвращает путь до файла.
   */
  final public String getPath()
  {
    return ( baseUrl_);
  }



  /** func: getName
   * Возвращает имя файла.
   */
  final public String getName()
  {
    return ( name_);
  }



  /** func: connectFtp
   * Устанавливает соединение с FTP-сервером и авторизуется
   */
  protected FTPClient connectFtp( String user, String password)
    throws IOException, FTPException
  {
    FTPClient fc = new FTPClient();
    fc.setRemoteHost( url_.getHost());  // Устанавливаем хост
    int port = url_.getPort();          // Устанавливаем порт, если задан
    if( port != -1)
      fc.setRemotePort( port);
    fc.setTimeout( TCP_TIMEOUT);        // Устанавливаем TCP-таймаут
    fc.setControlEncoding("Windows-1251");
    fc.connect();                       // Соединение с FTP
    fc.login( user, password);          // Выполняем login на FTP
                                        // Переходим в пассивный режим
    fc.setConnectMode(FTPConnectMode.PASV);

                                        // Специальные настройки для OS/400
    String system = fc.system();
    boolean isOS400 = system.trim().startsWith( OS400_SYSTEM_PREFIX);
    if( isOS400) {
                                        // Настраиваем парсинг листинга
      String[] validCodes = {"250"};    // Допускаем только успешный ответ
                                        // Устанавливаем формат листинга
      fc.quote( "SITE LIST 1", validCodes);
                                        // Устанавливаем Unix-парсер листинга
      fileFactory_ = new FTPFileFactory( new UnixFileParser());
    }
                                        // Специальные настройки для MS FTP
    else if ( system.trim().equals( MSFTPS_SYSTEM)) {
                                        // Устанавливаем Windows-парсер листинга
      fileFactory_ = new FTPFileFactory( new WindowsFileParser());
    }
    else
      fileFactory_ = new FTPFileFactory( system);
    fc.setFTPFileFactory( fileFactory_);
                                        // Устанавливаем локаль для парсинга
                                        // списка файлов каталога.
    fileFactory_.setLocale( new Locale( "en", "RU"));
    return fc;
  }



  /** proc: checkSecurityAlgorithm
   * Проверяет доступность алгоритма RSA.
   * В случае его отсутствия подключает дополнительного криптопровайдера
   * BouncyCastle.
   */
  protected void checkSecurityAlgorithm()
  {
    KeyFactory keyFactory = null;
    boolean isInstallBC = false;
                                        // Подключаем провайдера только при
                                        // недоступности алгоритма
    while( keyFactory == null) {
      try {
        keyFactory = KeyFactory.getInstance( "RSA");
      }
      catch( NoSuchAlgorithmException e) {
        if ( isInstallBC)
          throw new RuntimeException(
            "checkSecurityAlgorithm: " + e.getMessage()
          );
      }
      if ( keyFactory == null) {
        Security.addProvider( new BouncyCastleProvider());
        isInstallBC = true;
      }
    }
    return;
  }



  /** func: connectSftp
   * Устанавливает соединение с SFTP-сервером и авторизуется
   */
  protected SSHFTPClient connectSftp( String user, String password)
    throws IOException, FTPException
  {
    SSHFTPClient fc = new SSHFTPClient();
    fc.setRemoteHost( url_.getHost());  // Устанавливаем хост
    int port = url_.getPort();          // Устанавливаем порт, если задан
    if( port != -1)
      fc.setRemotePort( port);
    fc.setAuthentication( user, password);
    fc.getValidator().setHostValidationEnabled( false);
    fc.connect();                       // Соединение с FTP
    return fc;
  }



  /** func: dirDetails
   * Возвращает список файлов каталога.
   */
  protected FTPFile[] dirDetails(String dirname)
      throws IOException, FTPException
  {
    FTPFile ftpFile[] = null;
    String data[] = null;
    try {
      if ( fileFactory_ != null) {
        data = ftp_.dir( dirname, true);
        ftpFile = fileFactory_.parse( data);
      }
      else
        ftpFile = ftp_.dirDetails( dirname);
    }
    catch( java.text.ParseException e) {
      StringBuffer msg = new StringBuffer(
          data == null
            ? "Error on dirDetails.\n"
            : "Unparseable LIST answer:\n"
      );
      if( data != null) {
        for( int i = 0; i < data.length; ++i) {
          msg.append( data[i]);
          msg.append( '\n');
        }
      }
      msg.append( e.toString());
      msg.append( " (errorOffset=" + e.getErrorOffset() + ").\n");
      throw new FTPException( msg.toString());
    }
    return ftpFile;
  }


  /** func: checkState
   * Обновляет информацию о файле и возвращет его тип либо null, если файл не
   * существует.
   */
  public FileType checkState()
    throws IOException, FTPException
  {
    FileType fileType = null;
    if( name_.length() > 0) {           // Проверка наличия элемента каталога
                                        // Выполняем LIST для каталога
      FTPFile[] files;
      files = dirDetails( dirPath_);
                                        // Ищем файл по имени
      for (int i = 0; i < files.length; i++)
        if( name_.equalsIgnoreCase( files[i].getName())) {
                                        // Определяем тип файла
          fileType = files[i].isDir() ? FileType.DIRECTORY : FileType.FILE ;
          break;
        }
    }
    else if( dirPath_.length() > 0 ) {  // Проверка существования каталога
      String curDir = ftp_.pwd();       // Сохраняем исходный каталог
      try {                             // Пытаемся перейти в нужный каталог
        ftp_.chdir( dirPath_);
        fileType = FileType.DIRECTORY;
      } catch( FTPException e) {
        int replyCode = e.getReplyCode();
        if( replyCode / 10 != REPLAY_NOT_EXIST_PREFIX)
          throw e;
      }
      if( fileType != null)             // Восстанавливаем исходный каталог
        ftp_.chdir( curDir);
    }
    else                                // Это текущий каталог, т.к. нет пути
      fileType = FileType.DIRECTORY;
    return ( fileType);
  }



  /** func: dir
   * Возвращает массив с информацией о файлах каталога или null, если файл не
   * является каталогом либо не существует.
   * */
  public FileInfo[] dir()
    throws IOException, FTPException
  {
    FileInfo[] infos = null;
    FTPFile[] files = null;
    String curDir = null;
    if( path_.length() > 0) {
      curDir = ftp_.pwd();              // Сохраняем исходный каталог
      ftp_.chdir( path_);
    }
    try {
      files = dirDetails( "");
    }
    finally {
      if( curDir != null)
        ftp_.chdir( curDir);
    }
    if( files != null) {
      infos = new FileInfo[ files.length];
      for( int i = 0; i < infos.length; ++i)
        infos[ i] = new FtpFileInfo( files[ i]);
    }
    return ( infos);
  }

  /** func: getInputStream
   * Возвращает поток для чтения из файла
   */
  public InputStream getInputStream()
    throws IOException, FTPException
  {
     if ( isSftp_) {
       return new SSHFTPInputStream( sftpClient_, path_);
     }
     else {
       return new FTPInputStream( ftpClient_, path_);
     }
  }

  /** func: getOutputStream
   * Возвращает поток для записи в файл
   */
  public OutputStream getOutputStream( boolean append)
    throws IOException, FTPException
  {
     if (isSftp_) {
       return new SSHFTPOutputStream( sftpClient_, path_, append);
     }
     else {
       return new FTPOutputStream( ftpClient_, path_, append);
     }
  }

  /** proc: copy
   * Копирует файл
   */
  public void copy( String toPath, boolean overwrite)
    throws IOException, FTPException
  {
    File newPath = new File( toPath);
    if( newPath.isDirectory()) {          //Добавляем имя при копировании в
                                          //каталог
      newPath = new File( newPath, name_);
    }
    if( newPath.exists()) {
                                          //Проверяем флаг перезаписи
      if( !overwrite) {
        throw new java.lang.IllegalArgumentException(
          "Destination file '" + newPath.getPath() + "' already exist"
          );
      }
    }
    ftp_.get( newPath.getPath(), path_);
  }

  /** proc: delete
   * Удаляет файл
   */
  public void delete()
    throws IOException, FTPException
  {
    ftp_.delete( path_);
  }



  /** proc: renameTo
   * Пытается выполнить переименование файла.
   *
   * Параметры:
   * toPath                   - новый путь ( URL) к файлу
   * overwrite                - признак перезаписи файла
   *
   * Возврат:
   * true                     - в случае успеха
   * false                    - в случае неудачи
   */
  public boolean renameTo( String toPath, boolean overwrite)
    throws IOException, FTPException
  {
    return false;
  }



  /** proc: makeDirectory
   * Создаёт директорию
   *
   * raiseException           - флаг генерации исключения в случае
   *                            существования
   **/
  public void makeDirectory( boolean raiseException)
    throws IOException, FTPException
  {
    if ( ftp_.exists( path_)) {
      if ( raiseException) {
        throw new java.io.IOException(
          "Directory already exists : '" + path_ + '"'
        );
      }
    } else {
      ftp_.mkdir( path_);
    }
  }

} // FtpFile




/** class: FtpFileInfo
 * Содержит информацию о файле
 * ( подкласс класса <FileInfo>)
 */
final class FtpFileInfo extends FileInfo
{

  /** var: file_
   * Информация о файле.
   **/
  private FTPFile file_;



  /** func: FtpFileInfo
   * Создает новый объект на основе файла.
   */
  public FtpFileInfo( FTPFile file)
  {
    file_ = file;
  }



  /** func: name
   * Имя файла.
   **/
  public String name()
  {
    return ( file_.getName());
  }



  /** func: isFile
   * Возвращает истину, если файл является регулярным файлом.
   **/
  public boolean isFile()
  {
    return ( ! file_.isDir());
  }



  /** func: isDirectory
   * Возвращает истину, если файл является каталогом.
   **/
  public boolean isDirectory()
  {
    return ( file_.isDir());
  }



  /** func: length
   * Размер файла в байтах.
   **/
  public long length()
  {
    return ( file_.size());
  }



  /** func: lastModified
   * Дата последней модификации.
   **/
  public java.util.Date lastModified()
  {
    return ( file_.lastModified());
  }

}





/** class: NetFileImpl
 * Класс для работы с файлами через HTTP
 * ( подкласс класса <NetFileImpl>).
 *
 * Работа по HTTP реализована с помощью библиотеки <HttpClient>.
 */
class HttpFile extends NetFileImpl {

  /** var: baseUrl_
   * Исходный URL файла
   **/
  protected String baseUrl_;

  /** var: name_
   * Имя файла ( по умолчанию default.html)
   **/
  protected String name_;

  /** var: httpContext_
   * Контекст для выполнения HTTP-запросов ( null при использовании
   * контекста по-умолчанию)
   **/
  protected  HttpClientContext httpContext_;


  /** func: HttpFile
   * Создает объект по полному пути ( http://host[/path])
   */
  public HttpFile( java.lang.String path)
    throws
      IOException
      , java.net.MalformedURLException
      , java.sql.SQLException
  {
    baseUrl_ = path;
    URL url = new java.net.URL( path);
    if ( ! url.getProtocol().equalsIgnoreCase( "http"))
      throw new java.lang.IllegalArgumentException(
        "URL '" + path + "' does not use HTTP protocol."
      );
    name_ = url.getFile();
    if ( name_.length() == 0)
      name_ = "default.html";
    String targetProtocol = url.getProtocol();
    String targetHost = url.getHost();
    BigDecimal targetPort = new BigDecimal( ( double)(
      url.getPort() != -1 ? url.getPort() : url.getDefaultPort()
    ));
    String proxyServer;
    BigDecimal proxyPort;
    String proxyUsername;
    String proxyPassword;
    String proxyDomain;
    #sql {
      begin
        pkg_FileBase.getProxyConfig(
          serverAddress     => :OUT( proxyServer)
          , serverPort      => :OUT( proxyPort)
          , username        => :OUT( proxyUsername)
          , password        => :OUT( proxyPassword)
          , domain          => :OUT( proxyDomain)
          , targetProtocol  => :targetProtocol
          , targetHost      => :targetHost
          , targetPort      => :targetPort
        );
      end;
    };
    if ( proxyServer == null) {
      httpContext_ = null;
    }
    else {
      httpContext_ = HttpClientContext.create();
      HttpHost proxyHost = new HttpHost( proxyServer, proxyPort.intValue());
      String proxyWorkstation = "";
      CredentialsProvider credsProvider = new BasicCredentialsProvider();
      credsProvider.setCredentials(
        new AuthScope( proxyHost)
        , new NTCredentials(
            proxyUsername, proxyPassword, proxyWorkstation, proxyDomain
          )
      );
      httpContext_.setCredentialsProvider( credsProvider);
      httpContext_.setRequestConfig(
        RequestConfig.custom()
        .setProxy( proxyHost)
        .setProxyPreferredAuthSchemes( Arrays.asList( AuthSchemes.NTLM))
        .build()
      );
    }
  }



  /** func: getPath
   * Возвращает путь до файла.
   */
  final public String getPath()
  {
    return ( baseUrl_);
  }



  /** func: getName
   * Возвращает имя файла.
   */
  final public String getName()
  {
    return ( name_);
  }



  /** func: checkState
   * Обновляет информацию о файле и возвращет его тип либо null, если файл не
   * существует.
   */
  public FileType checkState()
    throws IOException, FTPException
  {
    FileType fileType = null;

    CloseableHttpClient client = HttpClients.createDefault();
    HttpHead request = new HttpHead( baseUrl_);
    CloseableHttpResponse response = client.execute( request, httpContext_);
    try {
      int statusCode = response.getStatusLine().getStatusCode();
      if ( statusCode == 200)
        fileType = FileType.FILE;
      else if ( statusCode != 404)
        throw new HttpResponseException(
          statusCode
          , response.getStatusLine().getReasonPhrase()
        );
    }
    finally {
      response.close();
    }

    return ( fileType);
  }



  /** func: dir
   * Возвращает массив с информацией о файлах каталога или null, если файл не
   * является каталогом либо не существует.
   * */
  public FileInfo[] dir()
    throws IOException, FTPException
  {
    return ( null);
  }



  /** func: getInputStream
   * Возвращает поток для чтения из файла
   */
  public InputStream getInputStream()
    throws IOException, FTPException
  {
    CloseableHttpClient client = HttpClients.createDefault();
    HttpGet request = new HttpGet( baseUrl_);
    CloseableHttpResponse response = client.execute( request, httpContext_);
    HttpEntity entity = response.getEntity();
    if ( entity == null) {
      response.close();
      throw new java.io.IOException(
        "Null HTTP entity."
      );
    }
    return ( entity.getContent());
  }



  /** func: getOutputStream
   * Возвращает поток для записи в файл
   */
  public OutputStream getOutputStream( boolean append)
    throws IOException, FTPException
  {
    throw new java.lang.UnsupportedOperationException(
      "Writing is not implemented for HTTP"
    );
  }



  /** proc: copy
   * Копирует файл
   */
  public void copy( String toPath, boolean overwrite)
    throws IOException, FTPException
  {
    File dstFile = new File( toPath);
    if ( dstFile.isDirectory()) {
      // Добавляем имя при копировании в каталог
      dstFile = new File( dstFile, name_);
    }
    if( dstFile.exists()) {
      if( !overwrite) {
        throw new java.lang.IllegalArgumentException(
          "Destination file '" + dstFile.getPath() + "' already exist"
          );
      }
    }

    CloseableHttpClient client = HttpClients.createDefault();
    HttpGet request = new HttpGet( baseUrl_);
    CloseableHttpResponse response = client.execute( request, httpContext_);
    try {
      final StatusLine statusLine = response.getStatusLine();
      if ( statusLine.getStatusCode() >= 300)
        throw new HttpResponseException(
          statusLine.getStatusCode()
          , statusLine.getReasonPhrase()
        );
      final FileOutputStream out = new FileOutputStream( dstFile);
      try {
        final HttpEntity entity = response.getEntity();
        if ( entity != null)
          entity.writeTo( out);
      }
      finally {
        out.close();
      }
    }
    finally {
      response.close();
    }
  }



  /** proc: delete
   * Удаляет файл
   */
  public void delete()
    throws IOException, FTPException
  {
    throw new java.lang.UnsupportedOperationException(
      "Deletion is not implemented for HTTP"
    );
  }



  /** proc: renameTo
   * Пытается выполнить переименование файла.
   *
   * Параметры:
   * toPath                   - новый путь ( URL) к файлу
   * overwrite                - признак перезаписи файла
   *
   * Возврат:
   * true                     - в случае успеха
   * false                    - в случае неудачи
   */
  public boolean renameTo( String toPath, boolean overwrite)
    throws IOException, FTPException
  {
    return false;
  }



  /** proc: makeDirectory
   * Создаёт директорию
   *
   * raiseException           - флаг генерации исключения в случае
   *                            существования
   **/
  public void makeDirectory( boolean raiseException)
    throws IOException, FTPException
  {
    throw new java.lang.UnsupportedOperationException(
      "Making directory is not implemented for HTTP"
    );
  }

} // HttpFile





/** class: NetFile
 * Предоставляет набор операции для работы с файлами, расположенными в локальной
 * файловой системе ( либо на Windows-шарах через UNC), доступным по FTP или
 * HTTP.
 */
public class NetFile
{

  /** var: logger
   * Логгер класса
   **/
  private static java.util.logging.Logger logger =
    java.util.logging.Logger.getLogger( "ru.company.netfile.NetFile")
  ;

  /** var: tempFileDir_
   * Каталог для временных файлов.
   **/
  private static String tempFileDir_ = "C:\\TEMP";

  /** var: class_
   * Тип файла
   **/
  private FileClass class_;

  /** var: file_
   * Объект для работы с файлом
   **/
  private NetFileImpl file_;

  /** var: type_
   * Тип файла
   **/
  private FileType type_;



  /** func: NetFile
   * Создает объект для работы с файлом
   **/
  public NetFile( String path)
    throws
      IOException
      , FTPException
      , java.net.MalformedURLException
      , java.sql.SQLException
  {
    class_ = FileClass.getFileClass( path);
    file_ = class_.makeNetFileImpl( path);
  }



  /** proc: setTempFileDir
   * Устанавливает каталог для временных файлов.
   **/
  public static void setTempFileDir( String tempFileDir)
  {
    tempFileDir_ = tempFileDir;
  }



  /** func: getPath
   * Возвращает путь до файла.
   */
  final public String getPath()
  {
    return ( file_.getPath());
  }



  /** func: getName
   * Возвращает имя файла.
   */
  final public String getName()
  {
    return ( file_.getName());
  }



  /** func: checkType
   * Возвращет истину, если тип файла соотвествует заданному
   **/
  protected boolean checkType( FileType expectedType)
    throws IOException, FTPException
  {
    if( type_ == null)
      type_ = file_.checkState();
    return ( type_ == expectedType);
  }



  /** func: exists
   * Возвращет истину, если файл существует
   **/
  final public boolean exists()
    throws IOException, FTPException
  {
    return ( ! checkType( null));
  }



  /** func: isFile
   * Возвращет истину, если файл является регулярным файлом
   **/
  final public boolean isFile()
    throws IOException, FTPException
  {
    return ( checkType( FileType.FILE));
  }



  /** func: isDirectory
   * Возвращет истину, если файл является каталогом
   **/
  final public boolean isDirectory()
    throws IOException, FTPException
  {
    return ( checkType( FileType.DIRECTORY));
  }



  /** func: dir
   * Возвращает массив с информацией о файлах каталога или null, если файл не
   * является каталогом либо не существует.
   */
  public FileInfo[] dir()
    throws IOException, FTPException
  {
    return ( file_.dir());
  }



  /** func: getInputStream
   * Возвращает поток для чтения из файла
   */
  public InputStream getInputStream()
    throws IOException, FTPException
  {
     return file_.getInputStream();
  }



  /** func: getOutputStream
   * Возвращает поток для записи в файл
   */
  public OutputStream getOutputStream(boolean append)
    throws IOException, FTPException
  {
     return file_.getOutputStream(append);
  }



  /** proc: copy
   * Копирует файл
   */
  public void copy( String toPath, boolean overwrite)
    throws
      IOException
      , FTPException
      , java.sql.SQLException
  {
    if( FileClass.getFileClass( toPath) == FileClass.FS)
      file_.copy( toPath, overwrite);
    else {
      NetFile dstFile = new NetFile( toPath);

      // Добавляем имя при копировании в каталог
      if( dstFile.isDirectory()) {
        String path = dstFile.getPath();
        path += ( path.length() > 0 ? "/" : "") + file_.getName();
        dstFile = new NetFile( path);
      }

      if( !overwrite) {
        if( dstFile.exists()) {
          throw new java.lang.IllegalArgumentException(
            "Destination file '" + dstFile.getPath() + "' already exist."
          );
        }
      }

      // Путь к загружаемому файлу
      String inputPath;

      // Временный файл
      File tmpFile = null;

      // Копируем данные во временный файл если источник не FS-файл
      if ( class_ != FileClass.FS) {
        File tmpDir = new File( tempFileDir_);
        String tmpName = "ora_jnf." + System.currentTimeMillis() + ".tmp";
        tmpFile = new File( tmpDir, tmpName);
        inputPath = tmpFile.getPath();
        file_.copy( inputPath, false);
      }
      else {
        inputPath = file_.getPath();
      }

      // Загружаем данные из файла
      FileInputStream input = new FileInputStream( inputPath);
      try {
        OutputStream outputStream = dstFile.getOutputStream( false);
        try {
          StreamConverter.binaryToBinary( outputStream, input);
          logger.fine(
            "copied file by streams: '"
            + inputPath + "' -> '" + dstFile.getPath() + "'"
          );
        }
        finally {
          outputStream.close();
        }
      }
      finally {
        input.close();
      }

      // Удаляем временный файл
      if( tmpFile != null) {
        tmpFile.delete();
        logger.fine( "deleted temp file: " + tmpFile.getPath());
      }
    }
  }



  /** proc: delete
   * Удаляет файл
   */
  public void delete()
    throws IOException, FTPException
  {
    file_.delete();
  }



  /** proc: move
   * Перемещает файл
   */
  public void move( String toPath, boolean overwrite)
    throws
      IOException
      , FTPException
      , java.sql.SQLException
  {
    boolean isOk = false;
    if ( class_ == FileClass.getFileClass( toPath))
      isOk = file_.renameTo( toPath, overwrite);
    if ( ! isOk) {
      copy( toPath, overwrite);
      delete();
    }
  }



  /** proc: makeDirectory
   * Создаёт директорию
   */
  public void makeDirectory( boolean raiseExceptionFlag)
    throws IOException, FTPException
  {
    file_.makeDirectory( raiseExceptionFlag);
  }

} // NetFile





/** class: NetFileImpl
 * Абстрактный базовый класс для реализации файловых операций.
 */
abstract class NetFileImpl
{

  /** func: getPath
   * Возвращает путь до файла.
   */
  abstract public String getPath()
  ;



  /** func: getName
   * Возвращает имя файла.
   */
  abstract public String getName()
  ;



  /** func: checkState
   * Обновляет информацию о файле и возвращет его тип либо null, если файл не
   * существует.
   */
  abstract public FileType checkState()
    throws IOException, FTPException
  ;

  /** func: dir
   * Возвращает массив с информацией о файлах каталога или null, если файл не
   * является каталогом либо не существует.
   */
  abstract public FileInfo[] dir()
    throws IOException, FTPException
  ;

  /** func: getInputStream
   * Возвращает поток для чтения из файла
   */
  abstract public InputStream getInputStream()
    throws IOException, FTPException
  ;

  /** func: getOutputStream
   * Возвращает поток для записи в файл
   */
  abstract public OutputStream getOutputStream( boolean append)
    throws IOException, FTPException
  ;

  /** proc: copy
   * Копирует файл
   */
  abstract public void copy( String toPath, boolean overwrite)
    throws IOException, FTPException
  ;

  /** proc: delete
   * Удаляет файл
   */
  abstract public void delete()
    throws IOException, FTPException
  ;

  /** proc: renameTo
   * Пытается выполнить переименование файла.
   *
   * Параметры:
   * toPath                   - новый путь ( URL) к файлу
   * overwrite                - признак перезаписи файла
   *
   * Возврат:
   * true                     - в случае успеха
   * false                    - в случае неудачи
   */
  abstract public boolean renameTo( String toPath, boolean overwrite)
    throws IOException, FTPException
  ;

  /** proc: makeDirectory
   * Создаёт директорию.
   */
  abstract public void makeDirectory( boolean raiseException)
    throws IOException, FTPException
  ;

} // NetFileImpl




/** class: ReaderInputStream
 * Класс для конвертации символьного входного потока в байтовый
 * ( подкласс класса java.io.InputStream)
 */
public class ReaderInputStream extends InputStream
{

  /** var: buf_
   * Буферный массив для хранения символов.
   **/
  private char[] buf_;


  /** var: arrayOutput_
   * Поток для записи в массив байт.
   **/
  private ArrayOutputStream arrayOutput_;

  /** var: outputWriter_
   * Поток для перевода символов в байты.
   **/
  private OutputStreamWriter outputWriter_;

  /** var: reader_
   * Символьный поток-источник.
   **/
  private Reader reader_;



  /** func: ReaderInputStream
   * Создает байтовый поток, связанный с указанным символьным потоком.
   **/
  public ReaderInputStream( Reader reader)
  {
    reader_ = reader;
  }



  /** proc: read
   * Читает один байт из потока.
   **/
  public int read()
    throws IOException
  {
    int b = reader_.read();             // Читаем символ из источника
    if( b != -1) {                      // Конвертируем в байт
      char[] ch = { (char) b };
      byte[] bytes = ( new String( ch)).getBytes();
      b = bytes[0];
      if( b < 0)                        // Приводим к диапазону [0,255]
        b = ( b & 0x7F) | 0x80 ;
    }
    return ( b);
  }



  /** func: read
   * Читает несколько байт из потока и сохраняет их в указанный массив.
   **/
  public int read(byte[] b, int off, int len)
    throws IOException
  {
    if( outputWriter_ == null) {        //Создаем потоки для конвертации.
      arrayOutput_ = new ArrayOutputStream();
      outputWriter_ = new OutputStreamWriter( arrayOutput_);
    }
                                        //Распределяем символьный буфер
    if( buf_ == null || buf_.length != b.length) {
      buf_ = new char[ b.length];
    }
    arrayOutput_.setBuffer( b, off);    //Устанавливаем буфер назначения
    int n = reader_.read( buf_, 0, len);//Читаем символы
    if( n != -1) {
      outputWriter_.write( buf_, 0, n);
      outputWriter_.flush();
                                        //Число байт не соответствует символам
      if( arrayOutput_.getCount() != off + n) {
        throw new IOException(
            "Bytes count do not equal character count( "
            + ( arrayOutput_.getCount() - off)
            + " and " + n + ")."
        );
      }
                                        //Копируем данные, если буфер изменился
      byte[] b2 = arrayOutput_.getBuffer();
      if( b2 != b) {
        System.arraycopy( b2, off, b, off, len);
      }
    }
    return ( n);
  }



  /** proc: close
   * Закрывает поток.
   **/
  public void close()
    throws IOException
  {
    if( outputWriter_ != null) {
      outputWriter_.close();
    }
    reader_.close();
  }

}




/** class: StreamConverter
 * Предоставляет набор утилит для конвертации потоков.
 */
public class StreamConverter {

/** const: BUFFER_SIZE
 * Размер буфера для записи в поток
 **/
final private static int BUFFER_SIZE = 1024 * 64;

/** func: logTrace
 * Добавляет отладочную запись в лог выполнения.
 *
 * Параметры:
 * messageText                - текст сообщения
 **/
public static void logTrace( java.lang.String messageText)
  throws
    SQLException
{
  #sql {
    declare
      lg lg_logger_t := lg_logger_t.GetLogger( 'File.StreamConverter.java');
    begin
      lg.trace( :messageText);
    end;
  };
}

/** func: binaryToBinary
 * Выгружает двоичные данные из входного потока в выходной.
 *
 * outputStream               - выходной поток
 * inputStream                - входной поток
 */
public static void binaryToBinary(
  OutputStream outputStream
  , InputStream inputStream
)
throws
  java.io.IOException
{
  byte buffer[] = new byte[ BUFFER_SIZE];
  int count = 0;
  BufferedOutputStream bufferedOutputStream = new BufferedOutputStream( outputStream, BUFFER_SIZE);
  BufferedInputStream bufferedInputStream = new BufferedInputStream( inputStream, BUFFER_SIZE);
  while ( ( count = bufferedInputStream.read( buffer, 0, buffer.length)) != - 1) {
    bufferedOutputStream.write( buffer, 0, count);
  }
  bufferedOutputStream.flush();
}

/** func: binaryToChar
 * Преобразует двоичные данные в текстовые.
 *
 * writer                     - выходной поток
 * inputStream                - входной поток
 * charEncoding               - символьная кодировка ( по-умолчанию кодировка БД)
 */
public static void binaryToChar(
  Writer writer
  , InputStream inputStream
  , String charEncoding
)
throws
  java.io.IOException
  , java.io.UnsupportedEncodingException
{
  if ( charEncoding == null ) {
    OutputStream outputStream = new WriterOutputStream( writer);
    binaryToBinary( outputStream, inputStream);
  } else {
    Reader reader = new InputStreamReader( inputStream, charEncoding);
    char buffer[] = new char[ BUFFER_SIZE];
    int count = 0;
    BufferedWriter bufferedWriter = new BufferedWriter( writer, BUFFER_SIZE);
    BufferedReader bufferedReader = new BufferedReader( reader, BUFFER_SIZE);
    while( ( count = bufferedReader.read( buffer, 0, buffer.length)) != - 1) {
      bufferedWriter.write( buffer, 0, count);
    }
    bufferedWriter.flush();
  }
}

/** func: charToBinary
 * Преобразует символьные данные в текстовые.
 *
 * reader                     - входной поток
 * outputStream               - выходной поток
 * charEncoding               - символьная кодировка ( по-умолчанию кодировка БД)
 */
public static void charToBinary(
  OutputStream outputStream
  , Reader reader
  , String charEncoding
)
throws
  java.io.IOException
  , java.io.UnsupportedEncodingException
  , java.sql.SQLException
{
  if ( charEncoding == null ) {
    InputStream inputStream = new ReaderInputStream( reader);
    binaryToBinary( outputStream, inputStream);
  } else {
    Writer writer = new OutputStreamWriter( outputStream, charEncoding);
    BufferedWriter bufferedWriter = new BufferedWriter( writer, BUFFER_SIZE);
    BufferedReader bufferedReader = new BufferedReader( reader, BUFFER_SIZE);
    char buffer[] = new char[ BUFFER_SIZE];
    int count = 0;
    while( ( count = bufferedReader.read( buffer, 0, buffer.length)) != - 1) {
      bufferedWriter.write( buffer, 0, count);
    }
    bufferedWriter.flush();
  }
}

}




/**
 * Класс для конвертации байтового выходного потока в символьный.
 **/
public class WriterOutputStream extends OutputStream
{

  /**
   * Буферный массив для сохранения конвертированных символов.
   **/
  private char[] buf_;

  /**
   * Поток для чтения массива байтов.
   **/
  private ArrayInputStream arrayInput_;

  /**
   * Поток для конвертации байтов в символы.
   **/
  private InputStreamReader inputReader_;

  /**
   * Символьный поток назначения.
   **/
  private Writer writer_;



  /**
   * Создает байтовый выходной поток в указанного символьного выходного потока.
   **/
  public WriterOutputStream( Writer writer)
  {
    writer_ = writer;
  }



  /**
   * Записывает один байт в поток.
   **/
  public void write( int b)
    throws IOException
  {
    byte[] bytes = new byte[1];
    bytes[ 0] = (byte)b;
    char ch = (new String( bytes)).charAt( 0);
    writer_.write( ch);
  }



  /**
   * Записывает массив байтов в поток.
   **/
  public void write(byte[] b, int off, int len)
    throws IOException
  {
    if( arrayInput_ == null) {          // Создает потоки для конвертации
      buf_ = new char[ b.length];
      arrayInput_ = new ArrayInputStream( b);
      inputReader_ = new InputStreamReader( arrayInput_);
    }
    else if( arrayInput_.getBuffer() != b)
      arrayInput_.setBuffer( b);
    arrayInput_.reset();                // Устанавливаем параметры источника
    if( off > 0)
      arrayInput_.skip( off);
    arrayInput_.setCount( off + len);
    int toRead = len;
    while( toRead > 0) {                // Конвертируем байты в символы
      int n = inputReader_.read( buf_, 0, buf_.length);
      if( n == -1)
        break;
      writer_.write( buf_, 0, n);       // Записываем символы в выходной поток
      toRead -= n;
    }
    if( toRead != 0) {                  // Проверка, что все символы считаны
      throw new IOException(
          "Bytes not fully converted to chars (lost " + toRead + " chars)"
      );
    }
  }



  /**
   * Закрывает поток и освобождает связанные с ним ресурсы.
   **/
  public void close()
    throws IOException
  {
    if( inputReader_ != null)           // Закрываем вспомогательные потоки
      inputReader_.close();
    if( writer_ != null)                // Закрываем нижележащий поток
      writer_.close();
  }

}
/
