create or replace type body dyn_dynamic_sql_t is
/* db object type body: dyn_dynamic_sql_t::body */


/* func: dyn_dynamic_sql_t
  Создает объект.

  Параметры:
  sqlText                     - базовый текст SQL-запроса
*/
constructor function dyn_dynamic_sql_t(
  sqlText                   in varchar2
)
return self as result
is
begin
  mSqlText        := sqlText;
  mConditionText  := null;
  groupText       := null;
  groupOpened     := 0;
  mParameterCount := 0;
  return;
end dyn_dynamic_sql_t;


/* proc: openGroup
  Open group of conditions
*/
member procedure openGroup
is
begin
  groupOpened := 1;
end openGroup;


/* proc: closeGroup
  Close group of conditions
  
  Params:
  
  logicalOperator           - logical operator ('and' by default)
*/
member procedure closeGroup(
  logicalOperator           in varchar2 := null
)
is
  vLogicalOperator          varchar2(10) := nvl(logicalOperator, 'and');
begin
  if groupOpened = 0 then
    raise_application_error(
      pkg_Error.IllegalArgument
    , 'Group has not been defined'
    );
  end if;
  mConditionText  := mConditionText         ||
    case
      when mConditionText is not null then
        ' ' || vLogicalOperator || ' '
    end                                     ||
    '(' || groupText || ')'
  ;
  groupText       := null;
  groupOpened     := 0;

end closeGroup;


/* proc: addCondition
  Добавляет условие в запрос.

  В случае, если фактическое значение параметра не null (isNullValue false),
  условие добавляется в виде бинарной операции сравнения над полем и параметром,
  в противном случае добавляется тождественно истинное условие с параметром.

  Указанная схема обеспечивает постоянное число и порядок параметров при
  выполнении динамического SQL при том, что фактически часть параметров
  может быть не задана (имеет значение null). Также обеспечивается разный
  текст запроса в зависимости от наличия фактических значений параметров,
  что позволяет использовать разные планы выполнения запроса.

  Параметры:
  conditionText               - текст условия
  isNullValue                 - признак null-значения параметра, используемого
                                в условии (в этом случае добавляется
                                тождественно истинное условие с параметром
                                вида ":<parameterName> is null")
  parameterName               - имя параметра для использования (по умолчанию
                                определяется автоматически)
  logicalOperator             - logical operator ('and' by default)

  Замечания:
  - в случае, если в тексте условия не используется параметр, то текст условия
    дополняется справа ссылкой на параметр, при этом наличие параметра в
    условии проверяется примитивно (по наличие двоеточия в тексте условия);
  - добавляемое условия объединяется с существующими условиями с помощью
    логического оператора "and";
  - имя параметра, используемого при дополнении условия либо в тривиальном
    условии, формируется автоматически (имя параметра из условия либо имя поля,
    используемого в условии вместе с алиасом, либо автогенерируемое вида
    "parameter<N>");

  Пример:

(code)

var rc refcursor

declare

function find(
  objectId number := null
  , objectName varchar2 := null
  , rowCount integer := null
)
return sys_refcursor
is

  -- Возвращаемый курсор
  rc sys_refcursor;

  -- Динамически формируемый текст запроса
  dsql dyn_dynamic_sql_t := dyn_dynamic_sql_t( '
select
  *
from
  user_objects t
'
  );

begin

  -- Добавляем условия в запрос
  dsql.addCondition(
    't.objectId =', objectId is null
  );
  dsql.addCondition(
    'upper(t.object_name) like upper(:objectName)'
    , objectName is null
  );
  dsql.addCondition(
    'rownum <=', rowCount is null, 'rowCount'
  );

  -- Вывод текста запроса для отладки
  pkg_Common.OutputMessage(dsql.getSqlText);

  -- Выполняем запрос
  open rc for
    dsql.getSqlText
  using
    objectId
    , objectName
    , rowCount
  ;
  return rc;
end find;

begin
  :rc := find(null, '%a%', 10);
end;

(end)
*/
member procedure addCondition(
  conditionText             in varchar2
, isNullValue               in boolean
, parameterName             in varchar2 := null
, logicalOperator           in varchar2 := null
)
is
  /*
    Возвращает истину, если в условии используется параметр.
  */
  function  isParameterUsed
  return    boolean
  is
  begin
    return
      instr(conditionText, ':') > 0
    ;
  end isParameterUsed;


  /*
    Возвращает истину, если строка является допустимым именем.
  */
  function  isName(
    str                     varchar2
  )
  return    boolean
  is
  begin
    return
      length(str) > 0
      and substr(str, 1, 1) <> '_'
      and translate(lower(str), '._abcdefghijklmnopqrstuvwxyz', '.') is null
    ;
  end isName;


  /*
    Возвращает имя параметра, используемого в условии или null, если параметр
    не используется.
  */
  function  getParameterName
  return    varchar2
  is
    -- Имя параметра
    parameterName           varchar2(30);

    -- Позиция двоеточия в строке
    iStart                  binary_integer := 1;

    -- Следующая позиция после имени параметра
    iEnd                    binary_integer;

    -- Возможная следующая позиция после имени параметра
    iEnd2                   binary_integer;

  -- getParameterName
  begin
    loop
      iStart := nvl(instr(conditionText, ':', iStart), 0);
      if iStart > 0 then

        -- Завершение по пробелу
        iEnd := instr(conditionText, ' ', iStart + 1);
        if iEnd = 0 then
          iEnd := length(conditionText) + 1;
        end if;

        -- Завершение по правой скобке
        iEnd2 := instr(conditionText, ')', iStart + 1);
        if iEnd2 > iStart and iEnd2 < iEnd then
          iEnd := iEnd2;
        end if;

        -- Выделение имени
        if iEnd > iStart + 1 then
          parameterName :=
            substr(conditionText, iStart + 1, iEnd - iStart - 1)
          ;
          if not coalesce(isName(parameterName), false) then
            parameterName := null;
          end if;
        end if;
        iStart := iEnd;
      end if;
      exit when iStart = 0 or parameterName is not null;
    end loop;
    return parameterName;
  end getParameterName;


  /*
    Создает имя параметра для использования вместе с условием.
  */
  function  makeParameterName
  return    varchar2
  is
    -- Имя параметра
    parameterName           varchar2(30);

    -- Позиция точки в строке
    iStart                  binary_integer;

    -- Позиция пробела в строке
    iEnd                    binary_integer;

  -- makeParameterName
  begin
    -- Пробуем создать имя по имени поля
    iStart := instr(conditionText, '.');
    if iStart > 0 then
      iEnd := instr(conditionText, ' ');
      if iEnd > iStart + 1 then
        parameterName := substr(conditionText, iStart + 1, iEnd - iStart - 1);
        if not coalesce(isName(parameterName), false) then
          parameterName := null;
        end if;
      end if;
    end if;

    -- Создаем автоматическое имя
    if parameterName is null then
      parameterName := 'parameter' || to_char(mParameterCount + 1);
    end if;
    return parameterName;
  end makeParameterName;


-- addCondition
begin
  addCondition(
    conditionText =>
      case
        when isNullValue then
          ':'
            || coalesce(parameterName, getParameterName(), makeParameterName())
            || ' is null'
        when isParameterUsed then
          conditionText
        else
          conditionText || ' :' || coalesce(parameterName, makeParameterName())
      end
  , logicalOperator => logicalOperator
  );

end addCondition;


/* proc: addCondition
  Add new filter condition

  Params:
  
  conditionText             - free text filter condition
  logicalOperator           - logical operator ('and' by default)
*/
member procedure addCondition(
  conditionText             in varchar2
, logicalOperator           in varchar2 := null
)
is
  vLogicalOperator          varchar2(10) := nvl(logicalOperator, 'and');
  tmpCondition              varchar2(32767);

begin
  tmpCondition      := 
    case
      when groupOpened = 1 then
        groupText
      else
        mConditionText
    end
  ;
  tmpCondition      := tmpCondition         ||
    case
      when tmpCondition is not null then
        ' ' || vLogicalOperator || ' '
    end                                     ||
    conditionText
  ;
  if groupOpened = 1 then
    groupText       := tmpCondition;
  else
    mConditionText  := tmpCondition;
  end if;

  mParameterCount   := mParameterCount + 1;

end addCondition;


/* func: useCondition
  Заменяет макропеременную $(macroName) в тексте запроса на выражение с
  параметрами.

  Параметры:
  macroName                   - имя макропеременной

  Замечания:
    - в случае если макропеременная в тексте не найдена, генерируется
      исключение;
    - информация о параметрах при вызове очищается;

  (см. пример <Test/complex-condition.sql>).
*/
member procedure useCondition(
  macroName                 in varchar2
)
is
  -- Текст для поиска в запросе
  usedMacro                 varchar2(1000);

-- useCondition
begin
  usedMacro := '$(' || macroName || ')';
  if instr(mSqlText, usedMacro) = 0 then
    raise_application_error(
      pkg_Error.IllegalArgument
      , 'Макропеременная ' || usedMacro || ' не найдена в тексте запроса'
    );
  end if;
  
  mSqlText        := replace(mSqlText, usedMacro, mConditionText);
  mConditionText  := null;
  groupText       := null;
  groupOpened     := 0;
  mParameterCount := 0;
end useCondition;


/* func: getSqlText
  Возвращает текст SQL-запроса.

  Замечания:
  - при наличии параметров к базовому текст SQL-запроса добавляется фраза
    " where " и параметры запроса;
*/
member function getSqlText
return varchar2
is
begin
  return
    case when mParameterCount > 0 then
      mSqlText || ' where ' || mConditionText
    else
      mSqlText
    end
  ;
end getSqlText;

end;
/
